"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateTestCases = void 0;
const tslib_1 = require("tslib");
const fs = tslib_1.__importStar(require("fs"));
const _ = tslib_1.__importStar(require("lodash"));
exports.generateTestCases = async (preparedJsonPath) => {
    const preparedJson = fs.readFileSync(preparedJsonPath).toString();
    const parsedPreparedJson = JSON.parse(preparedJson);
    const commandsArray = [];
    parsedPreparedJson.forEach((classItem) => {
        extractCommandDetailsFromClass(classItem, commandsArray, '', true);
    });
    generateTestFiles(commandsArray);
};
const formatClassName = (classNameToFormat) => {
    return _.capitalize(classNameToFormat.replace('-', ''));
};
const extractCommandDetailsFromClass = (classItem, commandsArray, parentCommand, isRootClass = false) => {
    var _a, _b;
    let command = parentCommand != '' ? `${parentCommand}.` : '';
    command += isRootClass
        ? formatClassName(classItem.name)
        : formatClassName(classItem.name).toLowerCase();
    if (classItem.param && ((_a = classItem.param) === null || _a === void 0 ? void 0 : _a.filter((x) => x).length) > 0) {
        command += `(${classItem.param.filter((x) => x).join(',')})`;
    }
    else if (isRootClass) {
        command += '()';
    }
    (_b = classItem.methods) === null || _b === void 0 ? void 0 : _b.forEach((method) => {
        const listOfParams = [];
        if (method.params.length > 0) {
            method.params.forEach((param) => {
                // const fullParam = `${param.name}${param.required == true ? '?' : ''}:${
                //   param.type
                // }`;
                //const fullParam = `${param.name}${param.required == true ? '?' : ''}`;
                const fullParam = `${param.name}`;
                listOfParams.push(fullParam);
            });
        }
        if (method.qsParams.length > 0) {
            method.qsParams.forEach((qsParam) => {
                // const fullQsParam = `${qsParam.name}${
                //   qsParam.required == true ? '?' : ''
                // }:${qsParam.type}`;
                // const fullQsParam = `${qsParam.name}${
                //     qsParam.required == true ? '?' : ''
                //   }`;
                const fullQsParam = `${qsParam.name}`;
                listOfParams.push(fullQsParam);
            });
        }
        let commandWithFilteredParameters = command;
        let listOfParamsToRemoveFromMethodArgs = [];
        // pull all the arguments in the extended command line into array. nuke the ones not in listOfParams.
        let regexp = /\{[a-zA-Z0-9]+\}/g;
        const argumentsInCommand = [...command.matchAll(regexp)];
        argumentsInCommand.forEach((argument) => {
            if (listOfParams
                .map((x) => x.split(':')[0])
                .map((x) => x.split('?')[0])
                .indexOf(argument[0].replace('{', '').replace('}', '')) < 0) {
                commandWithFilteredParameters = commandWithFilteredParameters.replace(argument[0], '');
                commandWithFilteredParameters = commandWithFilteredParameters
                    .replace('(,', '(')
                    .replace(',)', ')')
                    .replace(',,', ',');
                //commandWithFilteredParameters = commandWithFilteredParameters.replace("()","")
            }
            else {
                listOfParamsToRemoveFromMethodArgs.push(argument[0].replace('{', '').replace('}', ''));
            }
        });
        listOfParamsToRemoveFromMethodArgs.forEach((toRemove) => {
            _.remove(listOfParams, (x) => {
                return toRemove == x.split(':')[0].split('?')[0];
            });
        });
        if (method.verb == 'put' || method.verb == 'post') {
            listOfParams.unshift('body');
        }
        commandWithFilteredParameters = commandWithFilteredParameters.replace('{userId},me', '{userId}');
        commandWithFilteredParameters = commandWithFilteredParameters.replace(/\{([a-zA-Z0-9]+)}/g, '{$1:$1}');
        commandWithFilteredParameters = commandWithFilteredParameters.replace(/\},\{/g, ',');
        commandWithFilteredParameters = commandWithFilteredParameters.replace(/\(me\)/g, '({userId:"me"})');
        commandsArray.push([
            commandWithFilteredParameters +
                `.${method.verb}(${listOfParams.join(',')})`,
            method.url,
        ]);
    });
    if (classItem.subclasses) {
        classItem.subclasses.forEach((subclass) => extractCommandDetailsFromClass(subclass, commandsArray, command, false));
    }
};
const generateTestFiles = (commandArray) => {
    const classList = fs.readdirSync('./src/lib/client/generatedForProd/');
    classList
        .map((x) => x.replace('.ts', ''))
        .forEach((className) => {
        const commandList = commandArray.filter((x) => x[0].startsWith(_.capitalize(className) + '('));
        generateTestFile(className, commandList);
    });
    // commandArray.forEach(command)
    // let codeToReturn = ''
};
const extractBodyTypeFromCommand = (command) => {
    const splitCommand = command.split('.');
    // length-1 of that array gives the number of subclasses we need to go through
    splitCommand.shift();
    const readyToComposeCommandHierarchy = splitCommand.map((x) => _.capitalize(x.split('(')[0]));
    const namespacePath = readyToComposeCommandHierarchy
        .slice(0, readyToComposeCommandHierarchy.length - 2)
        .join('.');
    const typeName = readyToComposeCommandHierarchy
        .slice(readyToComposeCommandHierarchy.length - 2, readyToComposeCommandHierarchy.length)
        .join('') + 'BodyType';
    return namespacePath != '' ? `${namespacePath}.${typeName}` : `${typeName}`;
};
const generateTestFile = (className, commandList) => {
    const testFullFilename = './test/lib/' + className + '.test.ts';
    let codeToReturn = '';
    codeToReturn += `import ${_.capitalize(className)} from '../../../src/lib/client/generated/${className}'
    `;
    const namespacesToImport = [];
    commandList.forEach((command) => {
        if (command[0].indexOf('.put(') > 0 || command[0].indexOf('.post(') > 0) {
            const namespaceName = extractBodyTypeFromCommand(command[0])
                .split('.')
                .filter((x) => x)[0];
            if (!namespacesToImport.includes(namespaceName)) {
                namespacesToImport.push(namespaceName);
            }
        }
    });
    // namespacesToImport.forEach((namespace) => {
    //   codeToReturn += `import {${namespace}} from '../../../src/lib/client/generated/${className}'
    //       `;
    // });
    codeToReturn += `const fixtures = require('../../fixtures/${className}.json').fixtures

  `;
    codeToReturn += `describe('Testing ${_.capitalize(className)} class', () => {
        `;
    commandList.forEach((command) => {
        const commandMethod = command[0]
            .split('.')[command[0].split('.').length - 1].split('(')[0];
        const commandMethodArguments = command[0]
            .split('.')[command[0].split('.').length - 1].split('(')[1]
            .split(')')[0]
            .split(',');
        const commandCoordinates = command[0]
            .split('.')
            .map((x) => x.split('(')[0]);
        commandCoordinates.shift();
        codeToReturn += `   it('Testing endpoint: ${command[1]} - ${commandMethod.toUpperCase()} method', async () => {
            `;
        if (commandMethod == 'put' || commandMethod == 'post') {
            // extract the namespace(s) from command after the first class instantiation
            const bodyType = extractBodyTypeFromCommand(command[0]);
            //   codeToReturn += `const body: ${bodyType} = {body:fixtures.request.body.${commandCoordinates.join('.')}}
            //         `;
        }
        codeToReturn += `       const result = await new ${command[0]
            .replace(/:([a-zA-Z0-9]+)/g, `:fixtures.$1`)
            .replace(`${commandMethodArguments[0] != ''
            ? commandMethodArguments.join(',')
            : '###'}`, commandMethodArguments
            .map((x) => `fixtures.request.${commandCoordinates.join('.')}.` + x)
            .join(','))}
                            expect(result).toEqual(expect.objectContaining(fixtures.response.${commandCoordinates.join('.')}))
        `;
        codeToReturn += `   })
        `;
    });
    codeToReturn += `})
    `;
    fs.writeFileSync(testFullFilename, codeToReturn);
};
exports.generateTestCases('./snyk-prepared.json');
//# sourceMappingURL=generateTestCasesForProd.js.map