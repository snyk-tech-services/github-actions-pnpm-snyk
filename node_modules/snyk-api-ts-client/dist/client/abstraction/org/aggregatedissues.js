"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAggregatedIssuesWithVulnPaths = void 0;
const org_1 = require("../../generated/org");
const dep_graph_1 = require("@snyk/dep-graph");
exports.getAggregatedIssuesWithVulnPaths = async (classContext, body) => {
    var _a;
    const projectAggregatedIssues = await new org_1.Org({
        orgId: Object(classContext)['orgId'],
    })
        .project({ projectId: Object(classContext)['projectId'] })
        .aggregatedissues.post(body);
    const projectDepGraph = await new org_1.Org({
        orgId: Object(classContext)['orgId'],
    })
        .project({ projectId: Object(classContext)['projectId'] })
        .depgraph.get();
    const depGraph = dep_graph_1.createFromJSON(projectDepGraph.depGraph);
    let returnData = {
        issues: [],
    };
    (_a = projectAggregatedIssues === null || projectAggregatedIssues === void 0 ? void 0 : projectAggregatedIssues.issues) === null || _a === void 0 ? void 0 : _a.map((issue) => {
        const returnVulnPathsData = issue.pkgVersions.map((version) => {
            const pkg = {
                name: issue.pkgName,
                version: version,
            };
            return {
                [`${pkg.version}`]: getVulnPathsForPkgVersionFromGraph(pkg.name, pkg.version, depGraph),
            };
        });
        let newIssue = {
            pkgVersionsWithPaths: returnVulnPathsData,
            ...issue,
        };
        returnData.issues.push(newIssue);
    });
    return returnData;
};
const getVulnPathsForPkgVersionFromGraph = (pkgName, version, depGraph) => {
    const pkg = {
        name: pkgName,
        version: version,
    };
    const pkgVulnPaths = depGraph.pkgPathsToRoot(pkg);
    return pkgVulnPaths.map((vulnPath) => vulnPath
        .map((vulnPathPkg) => `${vulnPathPkg.name}@${vulnPathPkg.version}`)
        .reverse()
        .slice(1));
};
//# sourceMappingURL=aggregatedissues.js.map