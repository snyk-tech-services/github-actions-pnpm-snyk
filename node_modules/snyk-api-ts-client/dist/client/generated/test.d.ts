export declare class Test {
    private currentContext;
    private fullResponse;
    golangdep: Golangdep.Golangdep;
    govendor: Govendor.Govendor;
    yarn: Yarn.Yarn;
    composer: Composer.Composer;
    depgraph: Depgraph.Depgraph;
    constructor(fullResponse?: boolean);
    maven(Mavenparam?: mavenClass): Maven.Maven;
    npm(Npmparam?: npmClass): Npm.Npm;
    rubygems(Rubygemsparam?: rubygemsClass): Rubygems.Rubygems;
    gradle(Gradleparam?: gradleClass): Gradle.Gradle;
    sbt(Sbtparam?: sbtClass): Sbt.Sbt;
    pip(Pipparam?: pipClass): Pip.Pip;
}
interface mavenClass {
    groupId?: string;
    artifactId?: string;
    version?: string;
}
export interface MavenPostBodyType {
    /**
     * the encoding for the manifest files sent.
     */
    encoding?: 'plain' | 'base64';
    /**
     * The manifest files:
     */
    files: {
        /**
         * the main/root manifest file, encoded according the the "encoding" field.
         */
        target: {
            /**
             * The contents of the file, encoded according to the `encoding` field.
             */
            contents: string;
        };
        /**
         * additional manifest files (if needed), encoded according the the "encoding" field.
         */
        additional?: string[];
    };
}
export declare type MavenGetResponseType = any;
export declare type MavenPostResponseType = any;
export declare namespace Maven {
    class Maven {
        private currentContext;
        private groupId?;
        private artifactId?;
        private version?;
        constructor(parentContext: Object, Mavenparam?: mavenClass, fullResponse?: boolean);
        get(org?: string, repository?: string): Promise<any>;
        post(body: MavenPostBodyType, org?: string, repository?: string): Promise<any>;
    }
}
interface npmClass {
    packageName?: string;
    version?: string;
}
export interface NpmPostBodyType {
    /**
     * the encoding for the manifest files sent.
     */
    encoding?: 'plain' | 'base64';
    /**
     * The manifest files:
     */
    files: {
        /**
         * the `package.json` file, encoded according the the "encoding" field.
         */
        target: {
            /**
             * the contents of `package.json` as a string.
             */
            contents: string;
        };
        /**
         * a lockfile can be sent (if needed), encoded according the the "encoding" field.
         */
        additional?: string[];
    };
}
export declare type NpmGetResponseType = any;
export declare type NpmPostResponseType = any;
export declare namespace Npm {
    class Npm {
        private currentContext;
        private packageName?;
        private version?;
        constructor(parentContext: Object, Npmparam?: npmClass, fullResponse?: boolean);
        get(org?: string): Promise<any>;
        post(body: NpmPostBodyType): Promise<any>;
    }
}
export interface GolangdepPostBodyType {
    /**
     * the encoding for the manifest files sent.
     */
    encoding?: 'plain' | 'base64';
    /**
     * The manifest files:
     */
    files: {
        /**
         * the `Gopkg.toml` file, encoded according the the "encoding" field.
         */
        target: {
            contents?: string;
        };
        /**
         * a lockfile encoded according the the "encoding" field.
         */
        additional: string[];
    };
}
export declare type GolangdepPostResponseType = any;
export declare namespace Golangdep {
    class Golangdep {
        private currentContext;
        constructor(parentContext: Object, fullResponse?: boolean);
        post(body: GolangdepPostBodyType, org?: string): Promise<any>;
    }
}
export interface GovendorPostBodyType {
    /**
     * the encoding for the manifest files sent.
     */
    encoding?: 'plain' | 'base64';
    /**
     * The manifest files:
     */
    files: {
        /**
         * the `vendor.json` file, encoded according the the "encoding" field.
         */
        target: {
            contents?: string;
        };
    };
}
export declare type GovendorPostResponseType = any;
export declare namespace Govendor {
    class Govendor {
        private currentContext;
        constructor(parentContext: Object, fullResponse?: boolean);
        post(body: GovendorPostBodyType): Promise<any>;
    }
}
export interface YarnPostBodyType {
    /**
     * the encoding for the manifest files sent.
     */
    encoding?: 'plain' | 'base64';
    /**
     * The manifest files:
     */
    files: {
        /**
         * the `package.json` file, encoded according the the "encoding" field.
         */
        target: {
            /**
             * the contents of `package.json` as a string.
             */
            contents: string;
        };
        /**
         * a lockfile can be sent (if needed), encoded according the the "encoding" field.
         */
        additional?: string[];
    };
}
export declare type YarnPostResponseType = any;
export declare namespace Yarn {
    class Yarn {
        private currentContext;
        constructor(parentContext: Object, fullResponse?: boolean);
        post(body: YarnPostBodyType): Promise<any>;
    }
}
interface rubygemsClass {
    gemName?: string;
    version?: string;
}
export interface RubygemsPostBodyType {
    /**
     * the encoding for the manifest files sent.
     */
    encoding?: 'plain' | 'base64';
    /**
     * The manifest files:
     */
    files: {
        /**
         * the `Gemfile.lock` file, encoded according the the "encoding" field.
         */
        target: {
            /**
             * the contents of `Gemfile.lock` as a string.
             */
            contents: string;
        };
    };
}
export declare type RubygemsGetResponseType = any;
export declare type RubygemsPostResponseType = any;
export declare namespace Rubygems {
    class Rubygems {
        private currentContext;
        private gemName?;
        private version?;
        constructor(parentContext: Object, Rubygemsparam?: rubygemsClass, fullResponse?: boolean);
        get(org?: string): Promise<any>;
        post(body: RubygemsPostBodyType): Promise<any>;
    }
}
interface gradleClass {
    group?: string;
    name?: string;
    version?: string;
}
export interface GradlePostBodyType {
    /**
     * the encoding for the manifest files sent.
     */
    encoding?: 'plain' | 'base64';
    /**
     * The manifest files:
     */
    files: {
        /**
         * the manifest file, encoded according the the "encoding" field.
         */
        target: {
            /**
             * The contents of the file, encoded according to the `encoding` field.
             */
            contents: string;
        };
    };
}
export declare type GradleGetResponseType = any;
export declare type GradlePostResponseType = any;
export declare namespace Gradle {
    class Gradle {
        private currentContext;
        private group?;
        private name?;
        private version?;
        constructor(parentContext: Object, Gradleparam?: gradleClass, fullResponse?: boolean);
        get(org?: string, repository?: string): Promise<any>;
        post(body: GradlePostBodyType): Promise<any>;
    }
}
interface sbtClass {
    groupId?: string;
    artifactId?: string;
    version?: string;
}
export interface SbtPostBodyType {
    /**
     * the encoding for the manifest files sent.
     */
    encoding?: 'plain' | 'base64';
    /**
     * The manifest files:
     */
    files: {
        /**
         * the manifest file, encoded according the the "encoding" field.
         */
        target: {
            /**
             * The contents of the file, encoded according to the `encoding` field.
             */
            contents: string;
        };
    };
}
export declare type SbtGetResponseType = any;
export declare type SbtPostResponseType = any;
export declare namespace Sbt {
    class Sbt {
        private currentContext;
        private groupId?;
        private artifactId?;
        private version?;
        constructor(parentContext: Object, Sbtparam?: sbtClass, fullResponse?: boolean);
        get(org?: string, repository?: string): Promise<any>;
        post(body: SbtPostBodyType): Promise<any>;
    }
}
interface pipClass {
    packageName?: string;
    version?: string;
}
export interface PipPostBodyType {
    /**
     * the encoding for the manifest files sent.
     */
    encoding?: 'plain' | 'base64';
    /**
     * The manifest files:
     */
    files: {
        /**
         * the `requirements.txt` file, encoded according the the "encoding" field.
         */
        target: {
            /**
             * the contents of `requirements.txt` as a string, encoded according to `encoding` above.
             */
            contents: string;
        };
    };
}
export declare type PipGetResponseType = any;
export declare type PipPostResponseType = any;
export declare namespace Pip {
    class Pip {
        private currentContext;
        private packageName?;
        private version?;
        constructor(parentContext: Object, Pipparam?: pipClass, fullResponse?: boolean);
        get(org?: string): Promise<any>;
        post(body: PipPostBodyType): Promise<any>;
    }
}
export interface ComposerPostBodyType {
    /**
     * the encoding for the manifest files sent.
     */
    encoding?: 'plain' | 'base64';
    /**
     * The manifest files:
     */
    files: {
        /**
         * the `composer.json` file, encoded according the the "encoding" field.
         */
        target: {
            contents?: string;
        };
        /**
         * a lockfile encoded according the the "encoding" field.
         */
        additional: string[];
    };
}
export declare type ComposerPostResponseType = any;
export declare namespace Composer {
    class Composer {
        private currentContext;
        constructor(parentContext: Object, fullResponse?: boolean);
        post(body: ComposerPostBodyType): Promise<any>;
    }
}
export interface DepgraphPostBodyType {
    /**
     * A [DepGraph data object](https://github.com/snyk/dep-graph#depgraphdata) defining all packages and their relationships.
     */
    depGraph: {
        /**
         * Snyk DepGraph library schema version.
         */
        schemaVersion: string;
        /**
         * Package manager information.
         */
        pkgManager: {
            /**
             * Package manager name.
             */
            name: string;
            /**
             * A list of package repositories (i.e. maven-central, or npm) that defaults to the canonical package registry for the given package manager.
             */
            repositories?: string[];
        };
        /**
         * Array of package dependencies.
         */
        pkgs: string[];
        /**
         * Graph object references each pkg and how they depend on each other through the deps property.
         */
        graph: {
            /**
             * Root node id.
             */
            rootNodeId: string;
            /**
             * Array of node objects.
             */
            nodes: string[];
        };
    };
}
export declare type DepgraphPostResponseType = any;
export declare namespace Depgraph {
    class Depgraph {
        private currentContext;
        constructor(parentContext: Object, fullResponse?: boolean);
        post(body: DepgraphPostBodyType, org?: string): Promise<any>;
    }
}
export {};
