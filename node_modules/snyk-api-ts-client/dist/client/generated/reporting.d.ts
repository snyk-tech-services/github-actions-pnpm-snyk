export declare class Reporting {
    private currentContext;
    private fullResponse;
    issues: Issues.Issues;
    counts: Counts.Counts;
    constructor(fullResponse?: boolean);
}
export interface IssuesPostBodyType {
    filters?: {
        /**
         * The list of org IDs to filter the results by
         */
        orgs: {
            [key: string]: any;
        };
        /**
         * The severity levels of issues to filter the results by
         */
        severity?: string[];
        /**
         * The exploit maturity levels of issues to filter the results by
         */
        exploitMaturity?: string[];
        /**
         * The type of issues to filter the results by
         */
        types?: string[];
        /**
         * The type of languages to filter the results by
         */
        languages?: string[];
        /**
         * The list of project IDs to filter issues by
         */
        projects?: {
            [key: string]: any;
        };
        /**
         * The list of issue IDs to filter issues by
         */
        issues?: {
            [key: string]: any;
        };
        /**
         * Search term to filter issue name by, or an exact CVE or CWE
         */
        identifier?: string;
        /**
         * If set to `true`, only include issues which are ignored, if set to `false`, only include issues which are not ignored
         */
        ignored?: boolean;
        /**
         * If set to `true`, only include issues which are patched, if set to `false`, only include issues which are not patched
         */
        patched?: boolean;
        /**
         * If set to `true`, only include issues which are fixable, if set to `false`, only include issues which are not fixable. An issue is fixable if it is either upgradable, patchable or pinnable. Also see isUpgradable, isPatchable and isPinnable filters.
         */
        fixable?: boolean;
        /**
         * If set to `true`, only include issues which are fixed, if set to `false`, only include issues which are not fixed
         */
        isFixed?: boolean;
        /**
         * If set to `true`, only include issues which are upgradable, if set to `false`, only include issues which are not upgradable
         */
        isUpgradable?: boolean;
        /**
         * If set to `true`, only include issues which are patchable, if set to `false`, only include issues which are not patchable
         */
        isPatchable?: boolean;
        /**
         * If set to `true`, only include issues which are pinnable, if set to `false`, only include issues which are not pinnable
         */
        isPinnable?: boolean;
        /**
         * The priority score ranging between 0-1000
         */
        priorityScore?: {
            min?: number;
            max?: number;
        };
    };
}
export interface IssuesPostResponseType {
    /**
     * A list of issues
     */
    results: {
        /**
         * When no `groupBy` is used, a single project is returned per issue
         */
        project: {
            /**
             * URL to a page containing information about the project
             */
            url: string;
            /**
             * The identifier of the project
             */
            id: string;
            /**
             * The name of the project
             */
            name: string;
            /**
             * The source of the project (e.g. github, heroku etc)
             */
            source: string;
            /**
             * The package manager for the project (e.g. npm, rubygems etc)
             */
            packageManager: string;
            /**
             * The file path to the dependency manifest or lock file (e.g. package.json, Gemfile.lock etc)
             */
            targetFile?: string;
        };
    } | {
        /**
         * When `groupBy` is used, multiple projects may be returned per issue
         */
        projects: string[];
    }[];
    /**
     * The total number of results found
     */
    total: number;
}
export declare namespace Issues {
    class Issues {
        private currentContext;
        latest: Latest.Latest;
        constructor(parentContext: Object, fullResponse?: boolean);
        post(body: IssuesPostBodyType, from: string, to: string, page?: number, perPage?: number, sortBy?: string, order?: string, groupBy?: string): Promise<IssuesPostResponseType>;
        postAll(body: IssuesPostBodyType, from: string, to: string, sortBy?: string, order?: string, groupBy?: string, noLimitMode?: boolean): Promise<IssuesPostResponseType[]>;
    }
    interface LatestPostBodyType {
        filters?: {
            /**
             * The list of org IDs to filter the results by
             */
            orgs: {
                [key: string]: any;
            };
            /**
             * The severity levels of issues to filter the results by
             */
            severity?: string[];
            /**
             * The exploit maturity levels of issues to filter the results by
             */
            exploitMaturity?: string[];
            /**
             * The type of issues to filter the results by
             */
            types?: string[];
            /**
             * The type of languages to filter the results by
             */
            languages?: string[];
            /**
             * The list of project IDs to filter issues by
             */
            projects?: {
                [key: string]: any;
            };
            /**
             * The list of issue IDs to filter issues by
             */
            issues?: {
                [key: string]: any;
            };
            /**
             * Search term to filter issue name by, or an exact CVE or CWE
             */
            identifier?: string;
            /**
             * If set to `true`, only include issues which are ignored, if set to `false`, only include issues which are not ignored
             */
            ignored?: boolean;
            /**
             * If set to `true`, only include issues which are patched, if set to `false`, only include issues which are not patched
             */
            patched?: boolean;
            /**
             * If set to `true`, only include issues which are fixable, if set to `false`, only include issues which are not fixable. An issue is fixable if it is either upgradable, patchable or pinnable. Also see isUpgradable, isPatchable and isPinnable filters.
             */
            fixable?: boolean;
            /**
             * If set to `true`, only include issues which are fixed, if set to `false`, only include issues which are not fixed
             */
            isFixed?: boolean;
            /**
             * If set to `true`, only include issues which are upgradable, if set to `false`, only include issues which are not upgradable
             */
            isUpgradable?: boolean;
            /**
             * If set to `true`, only include issues which are patchable, if set to `false`, only include issues which are not patchable
             */
            isPatchable?: boolean;
            /**
             * If set to `true`, only include issues which are pinnable, if set to `false`, only include issues which are not pinnable
             */
            isPinnable?: boolean;
            /**
             * The priority score ranging between 0-1000
             */
            priorityScore?: {
                min?: number;
                max?: number;
            };
        };
    }
    interface LatestPostResponseType {
        /**
         * A list of issues
         */
        results: {
            /**
             * When no `groupBy` is used, a single project is returned per issue
             */
            project: {
                /**
                 * URL to a page containing information about the project
                 */
                url: string;
                /**
                 * The identifier of the project
                 */
                id: string;
                /**
                 * The name of the project
                 */
                name: string;
                /**
                 * The source of the project (e.g. github, heroku etc)
                 */
                source: string;
                /**
                 * The package manager for the project (e.g. npm, rubygems etc)
                 */
                packageManager: string;
                /**
                 * The file path to the dependency manifest or lock file (e.g. package.json, Gemfile.lock etc)
                 */
                targetFile?: string;
            };
        } | {
            /**
             * When `groupBy` is used, multiple projects may be returned per issue
             */
            projects: string[];
        }[];
        /**
         * The total number of results found
         */
        total: number;
    }
    namespace Latest {
        class Latest {
            private currentContext;
            constructor(parentContext: Object, fullResponse?: boolean);
            post(body: LatestPostBodyType, page?: number, perPage?: number, sortBy?: string, order?: string, groupBy?: string): Promise<LatestPostResponseType>;
            postAll(body: LatestPostBodyType, sortBy?: string, order?: string, groupBy?: string, noLimitMode?: boolean): Promise<LatestPostResponseType[]>;
        }
    }
}
export declare namespace Counts {
    class Counts {
        private currentContext;
        issues: Issues.Issues;
        projects: Projects.Projects;
        tests: Tests.Tests;
        constructor(parentContext: Object, fullResponse?: boolean);
    }
    interface IssuesPostBodyType {
        filters?: {
            /**
             * The list of org IDs to filter the results by
             */
            orgs: {
                [key: string]: any;
            };
            /**
             * The severity levels of issues to filter the results by
             */
            severity?: string[];
            /**
             * The type of issues to filter the results by
             */
            types?: string[];
            /**
             * The type of languages to filter the results by
             */
            languages?: string[];
            /**
             * The list of project IDs to filter issues by
             */
            projects?: {
                [key: string]: any;
            };
            /**
             * If set to `true`, only include issues which are ignored, if set to `false`, only include issues which are not ignored
             */
            ignored?: boolean;
            /**
             * If set to `true`, only include issues which are patched, if set to `false`, only include issues which are not patched
             */
            patched?: boolean;
            /**
             * If set to `true`, only include issues which are fixable, if set to `false`, only include issues which are not fixable. An issue is fixable if it is either upgradable, patchable or pinnable. Also see isUpgradable, isPatchable and isPinnable filters.
             */
            fixable?: boolean;
            /**
             * If set to `true`, only include issues which are upgradable, if set to `false`, only include issues which are not upgradable
             */
            isUpgradable?: boolean;
            /**
             * If set to `true`, only include issues which are patchable, if set to `false`, only include issues which are not patchable
             */
            isPatchable?: boolean;
            /**
             * If set to `true`, only include issues which are pinnable, if set to `false`, only include issues which are not pinnable
             */
            isPinnable?: boolean;
            /**
             * The priority score ranging between 0-1000
             */
            priorityScore?: {
                min?: number;
                max?: number;
            };
        };
    }
    interface IssuesPostResponseType {
        /**
         * A list of issue counts by day
         */
        results: {
            /**
             * The date in the format `YYYY-MM-DD`
             */
            day: string;
            /**
             * The number of issues
             */
            count: number;
            severity?: {
                /**
                 * The number of critical severity issues
                 */
                critical?: number;
                /**
                 * The number of high severity issues
                 */
                high?: number;
                /**
                 * The number of medium severity issues
                 */
                medium?: number;
                /**
                 * The number of low severity issues
                 */
                low?: number;
            };
            fixable?: {
                /**
                 * The number of fixable issues
                 */
                true?: number;
                /**
                 * The number of non-fixable issues
                 */
                false?: number;
            };
        }[];
    }
    namespace Issues {
        class Issues {
            private currentContext;
            latest: Latest.Latest;
            constructor(parentContext: Object, fullResponse?: boolean);
            post(body: IssuesPostBodyType, from: string, to: string, groupBy?: string): Promise<IssuesPostResponseType>;
        }
        interface LatestPostBodyType {
            filters?: {
                /**
                 * The list of org IDs to filter the results by
                 */
                orgs: {
                    [key: string]: any;
                };
                /**
                 * The severity levels of issues to filter the results by
                 */
                severity?: string[];
                /**
                 * The type of issues to filter the results by
                 */
                types?: string[];
                /**
                 * The type of languages to filter the results by
                 */
                languages?: string[];
                /**
                 * The list of project IDs to filter issues by
                 */
                projects?: {
                    [key: string]: any;
                };
                /**
                 * If set to `true`, only include issues which are ignored, if set to `false`, only include issues which are not ignored
                 */
                ignored?: boolean;
                /**
                 * If set to `true`, only include issues which are patched, if set to `false`, only include issues which are not patched
                 */
                patched?: boolean;
                /**
                 * If set to `true`, only include issues which are fixable, if set to `false`, only include issues which are not fixable. An issue is fixable if it is either upgradable, patchable or pinnable. Also see isUpgradable, isPatchable and isPinnable filters.
                 */
                fixable?: boolean;
                /**
                 * If set to `true`, only include issues which are upgradable, if set to `false`, only include issues which are not upgradable
                 */
                isUpgradable?: boolean;
                /**
                 * If set to `true`, only include issues which are patchable, if set to `false`, only include issues which are not patchable
                 */
                isPatchable?: boolean;
                /**
                 * If set to `true`, only include issues which are pinnable, if set to `false`, only include issues which are not pinnable
                 */
                isPinnable?: boolean;
                /**
                 * The priority score ranging between 0-1000
                 */
                priorityScore?: {
                    min?: number;
                    max?: number;
                };
            };
        }
        interface LatestPostResponseType {
            /**
             * A list of issue counts by day
             */
            results: {
                /**
                 * The date in the format `YYYY-MM-DD`
                 */
                day: string;
                /**
                 * The number of issues
                 */
                count: number;
                severity?: {
                    /**
                     * The number of critical severity issues
                     */
                    critical?: number;
                    /**
                     * The number of high severity issues
                     */
                    high?: number;
                    /**
                     * The number of medium severity issues
                     */
                    medium?: number;
                    /**
                     * The number of low severity issues
                     */
                    low?: number;
                };
                fixable?: {
                    /**
                     * The number of fixable issues
                     */
                    true?: number;
                    /**
                     * The number of non-fixable issues
                     */
                    false?: number;
                };
            }[];
        }
        namespace Latest {
            class Latest {
                private currentContext;
                constructor(parentContext: Object, fullResponse?: boolean);
                post(body: LatestPostBodyType, groupBy?: string): Promise<LatestPostResponseType>;
            }
        }
    }
    interface ProjectsPostBodyType {
        filters?: {
            /**
             * The list of org IDs to filter the results by
             */
            orgs: {
                [key: string]: any;
            };
            /**
             * The type of languages to filter the results by
             */
            languages?: string[];
            /**
             * The list of project IDs to filter the results by
             */
            projects?: {
                [key: string]: any;
            };
        };
    }
    interface ProjectsPostResponseType {
        /**
         * A list of project counts by day
         */
        results: {
            /**
             * The date in the format `YYYY-MM-DD`
             */
            day: string;
            /**
             * The number of projects
             */
            count: number;
        }[];
    }
    namespace Projects {
        class Projects {
            private currentContext;
            latest: Latest.Latest;
            constructor(parentContext: Object, fullResponse?: boolean);
            post(body: ProjectsPostBodyType, from: string, to: string): Promise<ProjectsPostResponseType>;
        }
        interface LatestPostBodyType {
            filters?: {
                /**
                 * The list of org IDs to filter the results by
                 */
                orgs: {
                    [key: string]: any;
                };
                /**
                 * The type of languages to filter the results by
                 */
                languages?: string[];
                /**
                 * The list of project IDs to filter the results by
                 */
                projects?: {
                    [key: string]: any;
                };
            };
        }
        interface LatestPostResponseType {
            /**
             * A list of project counts by day
             */
            results: {
                /**
                 * The date in the format `YYYY-MM-DD`
                 */
                day: string;
                /**
                 * The number of projects
                 */
                count: number;
            }[];
        }
        namespace Latest {
            class Latest {
                private currentContext;
                constructor(parentContext: Object, fullResponse?: boolean);
                post(body: LatestPostBodyType): Promise<LatestPostResponseType>;
            }
        }
    }
    interface TestsPostBodyType {
        filters?: {
            /**
             * The list of org IDs to filter the results by
             */
            orgs: {
                [key: string]: any;
            };
            /**
             * If set to `true`, only include tests which were conducted against private projects, if set to `false` only include tests which were conducted against public projects
             */
            isPrivate?: boolean;
            /**
             * If set to `true`, only include tests which prevented issues from being introduced, if set to `false` only include tests which did not prevent issues from being introduced
             */
            issuesPrevented?: boolean;
            /**
             * The list of project IDs to filter issues by
             */
            projects?: {
                [key: string]: any;
            };
        };
    }
    interface TestsPostResponseType {
        /**
         * A list of test counts
         */
        results: {
            /**
             * The number of tests conducted
             */
            count: number;
            isPrivate?: {
                /**
                 * The number of tests conducted against private projects
                 */
                true?: number;
                /**
                 * The number of tests conducted against public projects
                 */
                false?: number;
            };
            issuesPrevented?: {
                /**
                 * The number of tests that prevented issues from being introduced
                 */
                true?: number;
                /**
                 * The number of tests that did not prevent issues from being introduced
                 */
                false?: number;
            };
        }[];
    }
    namespace Tests {
        class Tests {
            private currentContext;
            constructor(parentContext: Object, fullResponse?: boolean);
            post(body: TestsPostBodyType, from: string, to: string, groupBy?: string): Promise<TestsPostResponseType>;
        }
    }
}
