"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTsInterfaceFromSwaggerSchema = exports.convert = void 0;
const utils_1 = require("./utils");
//   const propertyMapped = options
//   ? propertyMapper(schema.components.schemas, options.propertyMapper)
//   : schema.components.schemas;
const convert = (node, interfaceName) => {
    function transform(node) {
        switch (utils_1.nodeType(node)) {
            case 'string':
            case 'number':
            case 'boolean': {
                return utils_1.nodeType(node) || 'any';
            }
            case 'enum': {
                return utils_1.tsUnionOf(node.enum.map((item) => `'${item}'`));
            }
            case 'oneOf': {
                return utils_1.tsUnionOf(node.oneOf.map(transform));
            }
            case 'anyOf': {
                // return tsIntersectionOf(
                //   (node.anyOf as any[]).map((anyOf) => tsPartial(transform(anyOf))),
                // );
                // iterate over the node.anyOf, create the interfaces for each partial
                // and have a type being the interface joined by |
                let interfaceCodeToReturn = node.anyOf.map((anyOf, index) => `
        interface ${interfaceName}${index + 1} ${transform(anyOf)}
        `);
                interfaceCodeToReturn.unshift(`export type ${interfaceName} = ${node.anyOf
                    .map((value, index) => `${interfaceName + (index + 1)}`)
                    .join(' & ')} 
        `);
                return interfaceCodeToReturn.join('---');
                // return tsIntersectionOf(
                //   (node.anyOf as any[]).map((anyOf) => tsPartial(transform(anyOf))),
                // );
            }
            case 'object': {
                // if empty object, then return generic map type
                if ((!node.properties || !Object.keys(node.properties).length) &&
                    !node.allOf &&
                    !node.additionalProperties) {
                    if (node.type && node.type != 'object') {
                        return `${node.type[0]} | ${node.type[1]}`;
                    }
                    return `{ [key: string]: any }`;
                }
                let properties = createKeys(node.properties || {}, node.required);
                // if additional properties, add to end of properties
                if (node.additionalProperties) {
                    properties += `[key: string]: ${utils_1.nodeType(node.additionalProperties) || 'any'};\n`;
                }
                return utils_1.tsIntersectionOf([
                    ...(node.allOf ? node.allOf.map(transform) : []),
                    ...(properties ? [`{ ${properties} }`] : []),
                ]);
            }
            case 'array': {
                return utils_1.tsArrayOf(transform(node.items) || 'string');
            }
        }
        return '';
    }
    function createKeys(obj, required) {
        let output = '';
        Object.entries(obj).forEach(([key, value]) => {
            // 1. JSDoc comment (goes above property)
            if (value.description) {
                output += utils_1.comment(value.description);
            }
            // 2. name (with “?” if optional property)
            output += `"${key}"${!required || !required.includes(key) ? '?' : ''}: `;
            // 3. open nullable
            if (value.nullable) {
                output += '(';
            }
            // 4. transform
            output += transform(value);
            // 5. close nullable
            if (value.nullable) {
                output += ') | null';
            }
            // 6. close type
            output += ';\n';
        });
        return output;
    }
    return `${transform(node)}`;
    // note: make sure that base-level schemas are required
    //   return `
    //       ${createKeys(node, Object.keys(node))}
    //     `;
};
exports.convert = convert;
const getTsInterfaceFromSwaggerSchema = (interfaceName, schema) => {
    const convertedSchema = `${convert(schema, interfaceName)}
            `;
    if (convertedSchema.split('---').length <= 1) {
        return [
            `
    export interface ${interfaceName} ${convertedSchema}
    `,
        ];
    }
    else {
        return convertedSchema.split('---');
    }
};
exports.getTsInterfaceFromSwaggerSchema = getTsInterfaceFromSwaggerSchema;
//# sourceMappingURL=swagger-to-ts.js.map