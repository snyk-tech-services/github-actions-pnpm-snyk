"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertIntoIssueWithPath = exports.isVulnerablePathNew = void 0;
const _ = require("lodash");
const snyk_1 = require("../snyk/snyk");
const isVulnerablePathNew = (monitoredSnapshotPathArray, currentSnapshotPathArray) => {
    const versionPatternRegex = /@[a-zA-Z0-9-_\.]+$/;
    if (currentSnapshotPathArray.length === 0) {
        return false;
    }
    if (monitoredSnapshotPathArray.length != currentSnapshotPathArray.length) {
        // debug('###')
        // debug('Existing path')
        // debug(monitoredSnapshotPathArray)
        // debug('Current path')
        // debug(currentSnapshotPathArray)
        // debug('###')
        return true;
    }
    return !(_.isEqual(monitoredSnapshotPathArray, currentSnapshotPathArray) || currentSnapshotPathArray.every((path, index) => {
        if (monitoredSnapshotPathArray.length <= 0) {
            return false;
        }
        return path.split(versionPatternRegex)[0] == monitoredSnapshotPathArray[index].split(versionPatternRegex)[0];
    }));
};
exports.isVulnerablePathNew = isVulnerablePathNew;
const convertIntoIssueWithPath = async (aggregatedIssues, orgId, projectId) => {
    const issuesPostResponse = {
        ok: false,
        deprecated: undefined,
        issues: {
            vulnerabilities: [],
            licenses: [],
        },
        dependencyCount: undefined,
        packageManager: undefined
    };
    issuesPostResponse.deprecated = "undefined";
    issuesPostResponse.dependencyCount = 0;
    issuesPostResponse.packageManager = 'undefined';
    if (aggregatedIssues.issues) {
        let issueIndex = 0;
        while (issueIndex < aggregatedIssues.issues.length) {
            const aggregatedIssueData = aggregatedIssues.issues[issueIndex].issueData;
            const issuePaths = await snyk_1.getUpgradePath(orgId, projectId, aggregatedIssueData.id);
            const { cvssScore, ...everythingElse } = aggregatedIssueData;
            issuesPostResponse.ok = true;
            let pkgVersionIndex = 0;
            while (pkgVersionIndex < aggregatedIssues.issues[issueIndex].pkgVersions.length) {
                const versionKey = aggregatedIssues.issues[issueIndex].pkgVersions[pkgVersionIndex];
                if (aggregatedIssues.issues[issueIndex].issueType === 'vuln') {
                    let LegacyPathIndex = 0;
                    while (LegacyPathIndex < issuePaths.IssueFromLegacy.length) {
                        const issueDataWithMissingField = { from: [], package: '', upgradePath: [], version: '', isPatched: aggregatedIssues.issues[issueIndex].isPatched, isIgnored: aggregatedIssues.issues[issueIndex].isIgnored, cvssScore: parseInt(cvssScore), ...everythingElse };
                        issueDataWithMissingField.package = aggregatedIssues.issues[issueIndex].pkgName;
                        issueDataWithMissingField.version = versionKey;
                        issueDataWithMissingField.from = issuePaths.IssueFromLegacy[LegacyPathIndex];
                        issueDataWithMissingField.upgradePath = issuePaths.UpgradePathLegacy[LegacyPathIndex];
                        issuesPostResponse.issues.vulnerabilities.push(issueDataWithMissingField);
                        LegacyPathIndex++;
                    }
                }
                else if (aggregatedIssues.issues[issueIndex].issueType === 'license') {
                    let LegacyPathIndex = 0;
                    while (LegacyPathIndex < issuePaths.IssueFromLegacy.length) {
                        const issueDataWithMissingField = { from: [], package: '', upgradePath: [], version: '', isPatched: aggregatedIssues.issues[issueIndex].isPatched, isIgnored: aggregatedIssues.issues[issueIndex].isIgnored, cvssScore: parseInt(cvssScore), ...everythingElse };
                        issueDataWithMissingField.package = aggregatedIssues.issues[issueIndex].pkgName;
                        issueDataWithMissingField.version = versionKey;
                        issueDataWithMissingField.from = issuePaths.IssueFromLegacy[LegacyPathIndex];
                        issuesPostResponse.issues.licenses.push(issueDataWithMissingField);
                        LegacyPathIndex++;
                    }
                }
                pkgVersionIndex++;
            }
            issueIndex = issueIndex + 1;
        }
    }
    return issuesPostResponse;
};
exports.convertIntoIssueWithPath = convertIntoIssueWithPath;
//# sourceMappingURL=issuesUtils.js.map