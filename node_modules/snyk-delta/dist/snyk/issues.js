"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getIssuesDetailsPerPackage = exports.getNewIssues = void 0;
const _ = require("lodash");
const utils_1 = require("../utils/utils");
const issuesUtils_1 = require("../utils/issuesUtils");
var severityThresholds;
(function (severityThresholds) {
    severityThresholds[severityThresholds["low"] = 1] = "low";
    severityThresholds[severityThresholds["medium"] = 2] = "medium";
    severityThresholds[severityThresholds["high"] = 3] = "high";
    severityThresholds[severityThresholds["critical"] = 4] = "critical";
})(severityThresholds || (severityThresholds = {}));
const getNewIssues = (snykProject, snykTestJsonIssuesResults, inboundSeverityThreshold = 'low', mode) => {
    const debug = utils_1.getDebugModule();
    const MonitoredIssues = snykProject;
    debug(`Monitored snapshot had %d issues`, MonitoredIssues.length);
    const severityThreshold = Object.keys(severityThresholds).indexOf(inboundSeverityThreshold);
    debug(`Tested project has %d issues`, snykTestJsonIssuesResults.length);
    let newIssues = snykTestJsonIssuesResults;
    MonitoredIssues.forEach((monitoredIssue) => {
        newIssues = _.reject(newIssues, (issue) => {
            if (!issue.from || !monitoredIssue.from) {
                debug(`Error: Issue ${issue.id} does not have a vuln path in one of the snapshots`);
            }
            let issueFromArray = issue.from;
            let upgradePathArray = issue.upgradePath;
            if (mode == 'inline') {
                issueFromArray = issueFromArray.slice(1, issueFromArray.length);
                upgradePathArray = upgradePathArray ? upgradePathArray.slice(1, issueFromArray.length) : undefined;
            }
            return (monitoredIssue.id == issue.id &&
                !issuesUtils_1.isVulnerablePathNew(monitoredIssue.from, issueFromArray));
        });
    });
    debug('Severity threshold ', inboundSeverityThreshold);
    return newIssues.filter((issue) => Object.keys(severityThresholds).indexOf(issue.severity) >=
        severityThreshold);
};
exports.getNewIssues = getNewIssues;
const getIssuesDetailsPerPackage = (issuesArray, packageName, packageVersion) => {
    if (!packageVersion) {
        return [];
    }
    return issuesArray.filter((issues) => (issues.name == packageName || issues.package == packageName) &&
        issues.version == packageVersion);
};
exports.getIssuesDetailsPerPackage = getIssuesDetailsPerPackage;
//# sourceMappingURL=issues.js.map