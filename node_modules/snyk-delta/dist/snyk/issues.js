"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("../utils/utils");
const _ = require("lodash");
const chalk = require("chalk");
const terminalLink = require("terminal-link");
var severityThresholds;
(function (severityThresholds) {
    severityThresholds[severityThresholds["low"] = 1] = "low";
    severityThresholds[severityThresholds["medium"] = 2] = "medium";
    severityThresholds[severityThresholds["high"] = 3] = "high";
})(severityThresholds || (severityThresholds = {}));
const getNewVulns = (snykProject, snykTestJsonResults, mode) => {
    const debug = utils_1.getDebugModule();
    const MonitoredVulns = snykProject.issues.vulnerabilities;
    debug(`Monitored snapshot had %d vulns`, MonitoredVulns.length);
    const inboundSevThreshold = snykTestJsonResults.severityThreshold ? snykTestJsonResults.severityThreshold : "low";
    const severityThreshold = severityThresholds[inboundSevThreshold];
    let TestedVulns = snykTestJsonResults.vulnerabilities;
    TestedVulns = TestedVulns.filter(vuln => !vuln.type || vuln.type == 'vuln');
    debug(`Tested project has %d vulns`, TestedVulns.length);
    let newVulns = TestedVulns;
    MonitoredVulns.forEach(monitoredVuln => {
        newVulns = _.reject(newVulns, (vuln) => {
            let vulnFromArray = vuln.from;
            if (mode == 'inline') {
                vulnFromArray = vulnFromArray.slice(1, vulnFromArray.length);
            }
            return (monitoredVuln.id == vuln.id) && _.isEqual(monitoredVuln.from, vulnFromArray);
        });
    });
    debug("Severity threshold ", severityThresholds[inboundSevThreshold], inboundSevThreshold);
    return newVulns.filter(vuln => severityThresholds[vuln.severity] >= severityThreshold);
};
exports.getNewVulns = getNewVulns;
const getNewLicenseIssues = (snykProject, snykTestJsonResults, mode) => {
    const debug = utils_1.getDebugModule();
    const MonitoredLicenseIssues = snykProject.issues.licenses;
    debug(`Monitored snapshot had %d license issues`, MonitoredLicenseIssues.length);
    const inboundSevThreshold = snykTestJsonResults.severityThreshold ? snykTestJsonResults.severityThreshold : "low";
    const severityThreshold = severityThresholds[inboundSevThreshold];
    let TestedLicenseIssues;
    if (mode == 'inline') {
        TestedLicenseIssues = snykTestJsonResults.vulnerabilities;
        TestedLicenseIssues = TestedLicenseIssues.filter(vuln => vuln.type);
    }
    else {
        TestedLicenseIssues = snykTestJsonResults.licenses;
    }
    debug(`Tested project has %d license issues`, TestedLicenseIssues.length);
    let newLicenseIssues = TestedLicenseIssues;
    MonitoredLicenseIssues.forEach(monitoredLicenseIssue => {
        newLicenseIssues = _.reject(newLicenseIssues, (vuln) => {
            let licIssueFromArray = vuln.from;
            if (mode == 'inline') {
                licIssueFromArray = licIssueFromArray.slice(1, licIssueFromArray.length);
            }
            return (monitoredLicenseIssue.id == vuln.id) && _.isEqual(monitoredLicenseIssue.from, licIssueFromArray);
        });
    });
    debug("Severity threshold ", severityThresholds[inboundSevThreshold], inboundSevThreshold);
    return newLicenseIssues.filter(issue => severityThresholds[issue.severity] >= severityThreshold);
};
exports.getNewLicenseIssues = getNewLicenseIssues;
const displayNewVulns = (newVulns, mode) => {
    if (newVulns.length == 1) {
        console.log(chalk.bgHex('#fc9803')("\nNew issue introduced !"));
        console.log("Security Vulnerability:\n");
    }
    else if (newVulns.length > 1) {
        console.log(chalk.bgMagentaBright("\nNew issues introduced !"));
        console.log("Security Vulnerabilities:");
    }
    newVulns.forEach((vuln, index) => {
        const typedVuln = vuln;
        switch (vuln.severity) {
            case "high":
                console.log(chalk.bold.red(`  ${index + 1}/${newVulns.length}: ${vuln.title} [${_.capitalize(vuln.severity)} Severity]`));
                break;
            case "medium":
                console.log(chalk.bold.yellow(`  ${index + 1}/${newVulns.length}: ${vuln.title} [${_.capitalize(vuln.severity)} Severity]`));
                break;
            case "low":
                console.log(chalk.bold.blue(`  ${index + 1}/${newVulns.length}: ${vuln.title} [${_.capitalize(vuln.severity)} Severity]`));
                break;
            default:
                console.log(chalk.bold(`  ${index + 1}/${newVulns.length}: ${vuln.title} [${_.capitalize(vuln.severity)} Severity]`));
        }
        let paths = vuln.from;
        if (mode == 'inline') {
            paths.shift();
        }
        console.log(chalk("    Via:", paths.join(" => ")));
        if (vuln.fixedIn) {
            console.log(chalk.yellow("    Fixed in:", vuln.packageName, vuln.fixedIn.join(", ")));
            if (vuln.isUpgradable) {
                const upgradePaths = vuln.upgradePath;
                console.log(chalk.green("    Fixable by upgrade: ", upgradePaths.filter(vulnPath => vulnPath != false).join("=>")));
            }
            if (vuln.isPatchable) {
                const patchLink = terminalLink('patch', 'https://support.snyk.io/hc/en-us/articles/360003891078-Snyk-patches-to-fix');
                //console.log("    Fixable by ",patchLink,": ", vuln.patches.map(patch => patch.id))
                console.log(chalk.green("    Fixable by", patchLink, ": ", typedVuln.patches.map(patch => patch.id).join(", ")));
            }
        }
        console.log("\n");
    });
};
exports.displayNewVulns = displayNewVulns;
const displayNewLicenseIssues = (newLicenseIssues, mode) => {
    if (newLicenseIssues.length == 1) {
        console.log(chalk.bgHex('#fc9803')("\nNew issue introduced !"));
        console.log("License Issue:\n");
    }
    else if (newLicenseIssues.length > 1) {
        console.log(chalk.bgMagentaBright("\nNew issues introduced !"));
        console.log("License Issues:");
    }
    newLicenseIssues.forEach((issue, index) => {
        switch (issue.severity) {
            case "high":
                console.log(chalk.bold.red(`  ${index + 1}/${newLicenseIssues.length}: ${issue.title} [${_.capitalize(issue.severity)} Severity]`));
                break;
            case "medium":
                console.log(chalk.bold.yellow(`  ${index + 1}/${newLicenseIssues.length}: ${issue.title} [${_.capitalize(issue.severity)} Severity]`));
                break;
            case "low":
                console.log(chalk.bold.blue(`  ${index + 1}/${newLicenseIssues.length}: ${issue.title} [${_.capitalize(issue.severity)} Severity]`));
                break;
            default:
                console.log(chalk.bold(`  ${index + 1}/${newLicenseIssues.length}: ${issue.title} [${_.capitalize(issue.severity)} Severity]`));
        }
        let paths = issue.from;
        if (mode == 'inline') {
            paths.shift();
        }
        console.log(chalk("    Via:", paths.join(" => "), "\n"));
    });
};
exports.displayNewLicenseIssues = displayNewLicenseIssues;
const getIssuesDetailsPerPackage = (issuesArray, packageName, packageVersion) => {
    if (!packageVersion) {
        return [];
    }
    return issuesArray.filter(issues => (issues.name == packageName || issues.package == packageName) && issues.version == packageVersion);
};
exports.getIssuesDetailsPerPackage = getIssuesDetailsPerPackage;
//# sourceMappingURL=issues.js.map