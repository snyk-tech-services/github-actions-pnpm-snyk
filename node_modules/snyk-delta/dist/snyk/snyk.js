"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getUpgradePath = exports.getProjectUUID = exports.getProjectDepGraph = exports.getProjectIssues = exports.getProject = void 0;
const Error = require("../customErrors/apiError");
const snykClient = require("snyk-api-ts-client");
const issuesUtils_1 = require("../utils/issuesUtils");
const getProject = async (orgID, projectID) => {
    const project = await new snykClient.Org({ orgId: orgID })
        .project({ projectId: projectID })
        .get();
    return project;
};
exports.getProject = getProject;
const getProjectUUID = async (orgID, nonUUIDProjectID, projectType = 'cli') => {
    const allProjects = await new snykClient.Org({ orgId: orgID }).projects.post({});
    const allProjectsArray = allProjects.projects;
    const selectedProjectArray = allProjectsArray.filter((project) => project.name == nonUUIDProjectID && project.origin == projectType);
    if (selectedProjectArray.length == 0) {
        return '';
    }
    else if (selectedProjectArray.length > 1) {
        throw new Error.NotFoundError('Snyk API - Could not find a monitored project matching accurately. \
                                        Make sure to specify the right org when snyk test using --org. Branch support coming soon.');
    }
    return selectedProjectArray[0].id;
};
exports.getProjectUUID = getProjectUUID;
const getProjectIssues = async (orgID, projectID) => {
    // No filter on patched or non patch issue, getting both
    const filters = {
        includeDescription: false,
        includeIntroducedThrough: false,
        filters: {
            severities: ['high', 'medium', 'low', 'critical'],
            exploitMaturity: [
                'mature',
                'proof-of-concept',
                'no-known-exploit',
                'no-data',
            ],
            types: ['vuln', 'license'],
            ignored: false,
            patched: false,
            priority: {
                score: {
                    min: undefined,
                    max: undefined,
                },
            }
        }
    };
    const projectAggregatedIssues = await new snykClient.Org({ orgId: orgID })
        .project({ projectId: projectID })
        .aggregatedissues.getAggregatedIssuesWithVulnPaths(filters);
    return await issuesUtils_1.convertIntoIssueWithPath(projectAggregatedIssues, orgID, projectID);
};
exports.getProjectIssues = getProjectIssues;
const getProjectDepGraph = async (orgID, projectID) => {
    const projectDepGraph = await new snykClient.Org({ orgId: orgID })
        .project({ projectId: projectID })
        .depgraph.get();
    return projectDepGraph;
};
exports.getProjectDepGraph = getProjectDepGraph;
const getUpgradePath = async (orgID, projectID, issueId) => {
    let projectIssuePaths = await new snykClient.Org({ orgId: orgID })
        .project({ projectId: projectID }).issue({ issueId: issueId })
        .paths.get(undefined, 100, 1);
    const projectIssuePathsArray = [];
    projectIssuePathsArray.push(projectIssuePaths);
    if (projectIssuePaths.links && projectIssuePaths.links['next']) {
        let nextPageExist = true;
        let nextPage = 2;
        while (nextPageExist) {
            projectIssuePaths = await new snykClient.Org({ orgId: orgID })
                .project({ projectId: projectID }).issue({ issueId: issueId })
                .paths.get(undefined, 100, nextPage);
            nextPage++;
            projectIssuePathsArray.push(projectIssuePaths);
            if (projectIssuePaths.links && !projectIssuePaths.links['next']) {
                nextPageExist = false;
            }
        }
    }
    const projectIssuePathsLegacy = {
        UpgradePathLegacy: [],
        IssueFromLegacy: []
    };
    let depPathIndex = 0;
    let libNameArray = [];
    let fixVersionArray = [];
    projectIssuePathsArray.forEach(projectIssuePaths => {
        if (projectIssuePaths.paths) {
            projectIssuePaths.paths.map(depPath => {
                depPath.map(lib => {
                    const libName = lib.name + "@" + lib.version;
                    libNameArray.push(libName);
                    const fixVersionName = lib.name + "@" + lib.fixVersion;
                    if (lib.fixVersion) {
                        fixVersionArray.push(fixVersionName);
                    }
                });
                projectIssuePathsLegacy.IssueFromLegacy[depPathIndex] = libNameArray;
                if (fixVersionArray.length > 0) {
                    projectIssuePathsLegacy.UpgradePathLegacy[depPathIndex] = (fixVersionArray);
                }
                depPathIndex += 1;
                libNameArray = [];
                fixVersionArray = [];
            });
        }
    });
    return projectIssuePathsLegacy;
};
exports.getUpgradePath = getUpgradePath;
//# sourceMappingURL=snyk.js.map