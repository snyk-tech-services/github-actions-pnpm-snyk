"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.consolidateIndirectDepsPaths = exports.displayDependenciesChangeDetails = void 0;
const depgraph = require("@snyk/dep-graph");
const _ = require("lodash");
const chalk = require("chalk");
const issues_1 = require("../snyk/issues");
const displayDependenciesChangeDetails = async (snykDepsJsonResults, monitoredProjectDepGraph, packageManager, newVulns, newLicenseIssues) => {
    let snykTestGraph;
    if (snykDepsJsonResults && snykDepsJsonResults.depGraph) {
        // Getting graph
        snykTestGraph = depgraph.createFromJSON(snykDepsJsonResults.depGraph);
    }
    else {
        // Getting legacy dep tree
        snykTestGraph = await depgraph.legacy.depTreeToGraph(snykDepsJsonResults, packageManager);
    }
    const snykTestDirectDepsNodeIDs = snykTestGraph
        .toJSON()
        .graph.nodes[0].deps.map((dep) => dep.nodeId);
    const snykTestDirectDepsPkgIDs = [];
    snykTestDirectDepsNodeIDs.forEach((nodeId) => {
        const node = snykTestGraph
            .toJSON()
            .graph.nodes.find((node) => node.nodeId == nodeId);
        if (!node) {
            throw new Error(`Could not find node in graph ${nodeId}`);
        }
        else {
            snykTestDirectDepsPkgIDs.push(node.pkgId);
        }
    });
    const snykTestDirectDeps = snykTestGraph
        .toJSON()
        .pkgs.filter((pkg) => snykTestDirectDepsPkgIDs.indexOf(pkg.id) >= 0);
    const snykTestIndirectDeps = snykTestGraph
        .toJSON()
        .pkgs.filter((pkg) => snykTestDirectDepsPkgIDs.indexOf(pkg.id) < 0);
    const snykProjectGraph = depgraph.createFromJSON(monitoredProjectDepGraph.depGraph);
    const snykProjectDirectDepsNodeIDs = snykProjectGraph
        .toJSON()
        .graph.nodes[0].deps.map((dep) => dep.nodeId);
    const snykProjectDirectDepsPkgIDs = [];
    snykProjectDirectDepsNodeIDs.forEach((nodeId) => {
        const node = snykProjectGraph
            .toJSON()
            .graph.nodes.find((node) => node.nodeId == nodeId);
        if (!node) {
            throw new Error(`Could not find node in graph ${nodeId}`);
        }
        else {
            snykProjectDirectDepsPkgIDs.push(node.pkgId);
        }
    });
    const snykProjectDirectDeps = snykProjectGraph
        .toJSON()
        .pkgs.filter((pkg) => snykProjectDirectDepsPkgIDs.indexOf(pkg.id) >= 0);
    const snykProjectIndirectDeps = snykProjectGraph
        .toJSON()
        .pkgs.filter((pkg) => snykProjectDirectDepsPkgIDs.indexOf(pkg.id) < 0);
    const addedDirectDeps = _.differenceWith(snykTestDirectDeps, snykProjectDirectDeps, _.isEqual);
    const removedDirectDeps = _.differenceWith(snykProjectDirectDeps, snykTestDirectDeps, _.isEqual);
    const addedIndirectDeps = _.differenceWith(snykTestIndirectDeps, snykProjectIndirectDeps, _.isEqual);
    const removedIndirectDeps = _.differenceWith(snykProjectIndirectDeps, snykTestIndirectDeps, _.isEqual);
    console.log('_____________________________');
    console.log('Direct deps:');
    console.log(`Added ${addedDirectDeps.length} \n` + addedDirectDeps.map((dep) => dep.id));
    console.log('===============');
    console.log(`Removed ${removedDirectDeps.length}\n` +
        removedDirectDeps.map((dep) => dep.id));
    console.log('##################');
    console.log('Indirect deps:');
    console.log(`Added ${addedIndirectDeps.length} \n` +
        addedIndirectDeps.map((dep) => dep.id));
    console.log('===============');
    console.log('Paths');
    const consolidatedIndirectlyAddedDepsPaths = consolidateIndirectDepsPaths(addedIndirectDeps, snykTestGraph);
    addedIndirectDeps.forEach((addedDep) => {
        //Display all the indirect deps and their paths
        let allPathsForGivenDep = consolidatedIndirectlyAddedDepsPaths.get(addedDep.id);
        let vulnsForDep = issues_1.getIssuesDetailsPerPackage(newVulns, addedDep.info.name, addedDep.info.version);
        const vulnsCount = vulnsForDep.length;
        if (allPathsForGivenDep) {
            let count = '';
            let paths = '     ' +
                allPathsForGivenDep
                    .map((pathArr) => pathArr.join('=>'))
                    .join('\n       ');
            switch (vulnsCount) {
                case 0:
                    count = 'no issue';
                    paths = chalk.blue(paths);
                    break;
                case 1:
                    count = chalk.redBright('1 issue');
                default:
                    count = chalk.redBright(vulnsCount + ' issue');
                    paths = chalk.redBright(paths);
            }
            console.log('   ' + addedDep.id + ' ' + count + '' + ':\n' + paths);
        }
    });
    console.log('===============');
    console.log(`Removed ${removedIndirectDeps.length}\n`, removedIndirectDeps.map((dep) => dep.id));
    console.log('_____________________________');
    // TODO - Dep stats
    // health risk
    // internal usage
    // popularity
    // ranking
    // allowed/not allowed
    const consolidatedIndirectlyRemovedDepsPaths = consolidateIndirectDepsPaths(removedIndirectDeps, snykProjectGraph);
    addedIndirectDeps.forEach((removedDep) => {
        //Display all the indirect deps and their paths
        let allPathsForGivenDep = consolidatedIndirectlyRemovedDepsPaths.get(removedDep.id);
        if (allPathsForGivenDep) {
            console.log('   ', chalk.strikethrough(removedDep.id), ':\n', chalk.blue('     ', allPathsForGivenDep
                .map((pathArr) => pathArr.join('=>'))
                .join('\n       ')));
        }
    });
};
exports.displayDependenciesChangeDetails = displayDependenciesChangeDetails;
const consolidateIndirectDepsPaths = (listOfDeps, snykTestGraph) => {
    let snykIndirectDepsPaths = new Map();
    listOfDeps.forEach((indirectDep) => {
        snykTestGraph.pkgPathsToRoot(indirectDep.info).forEach((individualPath) => {
            // Group all paths for a given indirect dep together in a map
            let individualPathFormatted = individualPath
                .reverse()
                .slice(1)
                .map((pkgInfo) => pkgInfo.name + '@' + pkgInfo.version);
            if (snykIndirectDepsPaths.has(indirectDep.id)) {
                let pathsArray = snykIndirectDepsPaths.get(indirectDep.id);
                pathsArray.push(individualPathFormatted);
                snykIndirectDepsPaths.set(indirectDep.id, pathsArray);
            }
            else {
                let pathsArray = new Array();
                pathsArray.push(individualPathFormatted);
                snykIndirectDepsPaths.set(indirectDep.id, pathsArray);
            }
        });
    });
    return snykIndirectDepsPaths;
};
exports.consolidateIndirectDepsPaths = consolidateIndirectDepsPaths;
//# sourceMappingURL=dependencies.js.map