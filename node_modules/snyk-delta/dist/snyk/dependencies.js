"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const depgraph = require("@snyk/dep-graph");
const _ = require("lodash");
const chalk = require("chalk");
const issues_1 = require("../snyk/issues");
const displayDependenciesChangeDetails = async (snykDepsJsonResults, monitoredProjectDepGraph, packageManager, newVulns, newLicenseIssues) => {
    let snykTestGraph;
    if (snykDepsJsonResults && snykDepsJsonResults.depGraph) { // Getting graph
        snykTestGraph = depgraph.createFromJSON(snykDepsJsonResults.depGraph);
    }
    else { // Getting legacy dep tree
        snykTestGraph = await depgraph.legacy.depTreeToGraph(snykDepsJsonResults, packageManager);
    }
    //const snykTestDeps = snykTestGraph.getPkgs()
    const snykTestDirectDepsNodeIDs = snykTestGraph.toJSON().graph.nodes[0].deps.map(dep => dep.nodeId);
    const snykTestDirectDeps = snykTestGraph.toJSON().pkgs.filter(pkg => snykTestDirectDepsNodeIDs.indexOf(pkg.id) > 0);
    const snykTestIndirectDeps = snykTestGraph.toJSON().pkgs.filter(pkg => snykTestDirectDepsNodeIDs.indexOf(pkg.id) <= 0);
    const snykProjectGraph = depgraph.createFromJSON(monitoredProjectDepGraph.depGraph);
    //const snykProjectDeps = snykTestGraph.getPkgs()
    const snykProjectDirectDepsNodeIDs = snykProjectGraph.toJSON().graph.nodes[0].deps.map(dep => dep.nodeId);
    const snykProjectDirectDeps = snykProjectGraph.toJSON().pkgs.filter(pkg => snykProjectDirectDepsNodeIDs.indexOf(pkg.id) > 0);
    const snykProjectIndirectDeps = snykProjectGraph.toJSON().pkgs.filter(pkg => snykProjectDirectDepsNodeIDs.indexOf(pkg.id) <= 0);
    const addedDirectDeps = _.differenceWith(snykTestDirectDeps, snykProjectDirectDeps, _.isEqual);
    const removedDirectDeps = _.differenceWith(snykProjectDirectDeps, snykTestDirectDeps, _.isEqual);
    const addedIndirectDeps = _.differenceWith(snykTestIndirectDeps, snykProjectIndirectDeps, _.isEqual);
    const removedIndirectDeps = _.differenceWith(snykProjectIndirectDeps, snykTestIndirectDeps, _.isEqual);
    console.log("_____________________________");
    console.log("Direct deps:");
    console.log(`Added ${addedDirectDeps.length} \n` + addedDirectDeps.map(dep => dep.id));
    console.log("===============");
    console.log(`Removed ${removedDirectDeps.length}\n` + removedDirectDeps.map(dep => dep.id));
    console.log("##################");
    console.log("Indirect deps:");
    console.log(`Added ${addedIndirectDeps.length} \n` + addedIndirectDeps.map(dep => dep.id));
    console.log("===============");
    console.log("Paths");
    const consolidatedIndirectlyAddedDepsPaths = consolidateIndirectDepsPaths(addedIndirectDeps, snykTestGraph);
    addedIndirectDeps.forEach(addedDep => {
        //Display all the indirect deps and their paths
        let allPathsForGivenDep = consolidatedIndirectlyAddedDepsPaths.get(addedDep.id);
        //let depNameFormatted = arePathsRemoved? chalk.strikethrough(indirectDep.id): addedDep.id
        let vulnsForDep = issues_1.getIssuesDetailsPerPackage(newVulns, addedDep.info.name, addedDep.info.version);
        const vulnsCount = vulnsForDep.length;
        //let d =` - ${(vulnsForDep.length > 0? chalk.redBright(vulnsForDep.length+' vuln(s)'): '0 vuln')}`
        if (allPathsForGivenDep) {
            let count = '';
            let paths = '     ' + allPathsForGivenDep.map(pathArr => pathArr.join('=>')).join('\n       ');
            switch (vulnsCount) {
                case 0:
                    count = 'no issue';
                    paths = chalk.blue(paths);
                    break;
                case 1:
                    count = chalk.redBright('1 issue');
                default:
                    count = chalk.redBright(vulnsCount + ' issue');
                    paths = chalk.redBright(paths);
            }
            console.log('   ' + addedDep.id + ' ' + count + '' + ':\n' + paths);
        }
    });
    //console.log(snykTestAddedIndirectDepsPaths)
    console.log("===============");
    console.log(`Removed ${removedIndirectDeps.length}\n`, removedIndirectDeps.map(dep => dep.id));
    console.log("_____________________________");
    // console.log(chalk.strikethrough(addedDirectDeps))
    // TODO - Dep stats
    // health risk
    // internal usage
    // popularity
    // ranking
    // allowed/not allowed
    // displayIndirectDepsConsolidatedPath(removedIndirectDeps,snykProjectGraph, true)
    const consolidatedIndirectlyRemovedDepsPaths = consolidateIndirectDepsPaths(removedIndirectDeps, snykProjectGraph);
    addedIndirectDeps.forEach(removedDep => {
        //Display all the indirect deps and their paths
        let allPathsForGivenDep = consolidatedIndirectlyRemovedDepsPaths.get(removedDep.id);
        if (allPathsForGivenDep) {
            console.log('   ', chalk.strikethrough(removedDep.id), ':\n', chalk.blue('     ', allPathsForGivenDep.map(pathArr => pathArr.join('=>')).join('\n       ')));
        }
    });
};
exports.displayDependenciesChangeDetails = displayDependenciesChangeDetails;
const consolidateIndirectDepsPaths = (listOfDeps, snykTestGraph) => {
    let snykIndirectDepsPaths = new Map();
    listOfDeps.forEach(indirectDep => {
        snykTestGraph.pkgPathsToRoot(indirectDep.info).forEach(individualPath => {
            // Group all paths for a given indirect dep together in a map
            let individualPathFormatted = individualPath.reverse().slice(1).map(pkgInfo => pkgInfo.name + '@' + pkgInfo.version);
            if (snykIndirectDepsPaths.has(indirectDep.id)) {
                let pathsArray = snykIndirectDepsPaths.get(indirectDep.id);
                pathsArray.push(individualPathFormatted);
                snykIndirectDepsPaths.set(indirectDep.id, pathsArray);
            }
            else {
                let pathsArray = new Array();
                pathsArray.push(individualPathFormatted);
                snykIndirectDepsPaths.set(indirectDep.id, pathsArray);
            }
        });
    });
    return snykIndirectDepsPaths;
};
exports.consolidateIndirectDepsPaths = consolidateIndirectDepsPaths;
//# sourceMappingURL=dependencies.js.map