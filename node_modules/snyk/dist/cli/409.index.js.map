{"version":3,"file":"409.index.js","mappings":"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AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,OAAO;AACP;AACA,GAAG;AACH;;AAEA;;;;;;;;AChPA;;AAEA,cAAc,mBAAO,CAAC,KAAO;AAC7B,0BAA0B,mBAAO,CAAC,KAAuB;;AAEzD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA,GAAG,IAAI;;AAEP;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;;;;;;;AC1CA;;AAEA,cAAc,mBAAO,CAAC,KAAO;AAC7B,gBAAgB,mBAAO,CAAC,IAAc;AACtC,aAAa,mBAAO,CAAC,KAAM;AAC3B,iBAAiB,mCAAsB;AACvC,QAAQ,qCAAqC,EAAE,mBAAO,CAAC,KAAa;;AAEpE;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;ACrDA;;AAEA,cAAc,mBAAO,CAAC,KAAO;AAC7B,sBAAsB,mBAAO,CAAC,KAAkB;AAChD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO,IAAI;;AAEX;AACA;;AAEA;AACA,GAAG;AACH;;;;;;;;ACtCA;AACA,UAAU,mBAAO,CAAC,IAAU;AAC5B,UAAU,2CAA0B;AACpC,WAAW,4CAA2B;AACtC,cAAc,+CAA8B;AAC5C,SAAS,mBAAO,CAAC,KAAS;AAC1B,qBAAqB,mBAAO,CAAC,KAAuB;AACpD;AACA,CAAC;;AAED,cAAc,mBAAO,CAAC,KAAO;;AAE7B,oBAAoB,mBAAO,CAAC,KAAoB;AAChD,cAAc,mBAAO,CAAC,KAAc;;AAEpC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,GAAG;AACH;;;;;;;;ACtCA;;AAEA;;AAEA,cAAc,mBAAO,CAAC,KAAO;AAC7B,cAAc,mBAAO,CAAC,KAAO;AAC7B,aAAa,mBAAO,CAAC,KAAM;AAC3B,cAAc,mBAAO,CAAC,KAAO;AAC7B,WAAW,mBAAO,CAAC,KAAI;AACvB,aAAa,mBAAO,CAAC,KAAM;AAC3B,gBAAgB,mBAAO,CAAC,IAAgB;AACxC,kBAAkB,mBAAO,CAAC,KAAkB;AAC5C,QAAQ,wBAAwB,EAAE,mBAAO,CAAC,KAAW;AACrD,mBAAmB,mBAAO,CAAC,KAAe;AAC1C,sBAAsB,mBAAO,CAAC,KAAkB;AAChD,sBAAsB,mBAAO,CAAC,KAAmB;AACjD,eAAe,mBAAO,CAAC,KAAkB;AACzC,uBAAuB,mBAAO,CAAC,KAAoB;AACnD,QAAQ,UAAU,EAAE,mBAAO,CAAC,KAAY;AACxC,eAAe,mBAAO,CAAC,KAAyB;AAChD,kBAAkB,mBAAO,CAAC,KAAc;AACxC,QAAQ,wBAAwB,EAAE,mBAAO,CAAC,KAAe;;AAEzD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,0CAA0C;;AAE1C;AACA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC,SAAS,EAAE,UAAU;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gDAAgD;AAC5E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B;AAC3B;AACA,uBAAuB;AACvB,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;;AAEb;AACA;AACA,0BAA0B;AAC1B,aAAa;AACb,WAAW;AACX,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa,IAAI;;AAEjB;;AAEA;AACA,WAAW;;AAEX;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzOA;;AAEA,eAAe,mBAAO,CAAC,KAAQ;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;ACbA;;AAEA,QAAQ,qCAAqC,EAAE,mBAAO,CAAC,KAAa;;AAEpE;AACA;AACA;AACA,GAAG;AACH;;;;;;;;ACRA,iBAAqB;AACrB,iBAAsB;AACtB,iBAAyB;;AAEzB,cAAc,mBAAO,CAAC,KAAO;AAC7B,cAAc,mBAAO,CAAC,KAAO;AAC7B,aAAa,mBAAO,CAAC,KAAa;AAClC,gBAAgB,mBAAO,CAAC,KAAgB;AACxC,QAAQ,qCAAqC,EAAE,mBAAO,CAAC,KAAa;AACpE,eAAe,mBAAO,CAAC,KAAQ;AAC/B,eAAe,mBAAO,CAAC,KAAyB;AAChD,QAAQ,eAAe,EAAE,mBAAO,CAAC,KAAQ;AACzC,QAAQ,OAAO,EAAE,mBAAO,CAAC,KAAS;AAClC,QAAQ,UAAU,EAAE,mBAAO,CAAC,KAAY;AACxC,kBAAkB,mBAAO,CAAC,KAAc;;AAExC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,IAAI;;AAEf;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;ACnLA;;AAEA,cAAc,mBAAO,CAAC,KAAO;AAC7B,WAAW,mBAAO,CAAC,KAAI;AACvB,aAAa,mBAAO,CAAC,KAAM;;AAE3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH","sources":["webpack://snyk/./src/lib/npm.ts","webpack://snyk/./src/lib/protect/fetch-patch.ts","webpack://snyk/./src/lib/yarn.ts","webpack://snyk/./src/lib/protect/apply-patch.js","webpack://snyk/./src/lib/protect/dedupe-patches.js","webpack://snyk/./src/lib/protect/get-vuln-source.js","webpack://snyk/./src/lib/protect/ignore.js","webpack://snyk/./src/lib/protect/index.js","webpack://snyk/./src/lib/protect/patch.js","webpack://snyk/./src/lib/protect/patches-for-package.js","webpack://snyk/./src/lib/protect/strip-versions.js","webpack://snyk/./src/lib/protect/update.js","webpack://snyk/./src/lib/protect/write-patch-flag.js"],"sourcesContent":["import debugModule = require('debug');\nconst debug = debugModule('snyk');\nimport { exec } from 'child_process';\n\nexport default function npm(\n  method: string,\n  packages: string[] | null,\n  live: boolean,\n  cwd: string | null,\n  flags: string[] | null,\n): Promise<void> {\n  flags = flags || [];\n  if (!packages) {\n    packages = [];\n  }\n\n  if (!Array.isArray(packages)) {\n    packages = [packages];\n  }\n\n  // only if we have packages, then always save, otherwise the command might\n  // be something like `npm shrinkwrap'\n  if (packages.length && !flags.length) {\n    flags.push('--save');\n  }\n\n  method += ' ' + flags.join(' ');\n\n  return new Promise((resolve, reject) => {\n    const cmd = 'npm ' + method + ' ' + (packages as string[]).join(' ');\n    if (!cwd) {\n      cwd = process.cwd();\n    }\n    debug('%s$ %s', cwd, cmd);\n\n    if (!live) {\n      debug('[skipping - dry run]');\n      return resolve();\n    }\n\n    exec(\n      cmd,\n      {\n        cwd,\n      },\n      (error, stdout, stderr) => {\n        if (error) {\n          return reject(error);\n        }\n\n        if (stderr.indexOf('ERR!') !== -1) {\n          console.error(stderr.trim());\n          const e = new Error('npm update issues: ' + stderr.trim());\n          (e as any).code = 'FAIL_UPDATE';\n          return reject(e);\n        }\n\n        debug('npm %s complete', method);\n\n        resolve();\n      },\n    );\n  });\n}\n\nexport function getVersion() {\n  return new Promise((resolve, reject) => {\n    exec(\n      'npm --version',\n      {\n        cwd: process.cwd(),\n      },\n      (error, stdout) => {\n        if (error) {\n          return reject(error);\n        }\n        return resolve(stdout);\n      },\n    );\n  });\n}\n","import * as fs from 'fs';\nimport * as analytics from '../analytics';\nimport * as debugModule from 'debug';\nimport { makeRequest } from '../request';\n\nconst debug = debugModule('snyk:fetch-patch');\n\nexport default async function getPatchFile(\n  patchUrl: string,\n  patchFilename: string,\n): Promise<string> {\n  try {\n    const response = await makeRequest({ url: patchUrl });\n    if (\n      !response ||\n      !response.res ||\n      !response.body ||\n      response.res.statusCode !== 200\n    ) {\n      throw response;\n    }\n    fs.writeFileSync(patchFilename, response.body);\n    debug(\n      `Fetched patch from ${patchUrl} to ${patchFilename}, patch size ${response.body.length} bytes`,\n    );\n  } catch (error) {\n    const errorMessage = `Failed to fetch patch from ${patchUrl} to ${patchFilename}`;\n    debug(errorMessage, error);\n    analytics.add('patch-fetch-fail', {\n      message: (error && error.message) || errorMessage,\n      code: error && error.res && error.res.statusCode,\n      patchFilename,\n      patchUrl,\n    });\n    throw new Error(errorMessage);\n  }\n  return patchFilename;\n}\n","import * as Debug from 'debug';\nimport { exec } from 'child_process';\nimport { CustomError } from './errors';\n\nconst debug = Debug('snyk');\n\nexport function yarn(\n  method: string,\n  packages: string[],\n  live: boolean,\n  cwd: string,\n  flags: string[],\n) {\n  flags = flags || [];\n  if (!packages) {\n    packages = [];\n  }\n\n  if (!Array.isArray(packages)) {\n    packages = [packages];\n  }\n\n  method += ' ' + flags.join(' ');\n\n  return new Promise((resolve, reject) => {\n    const cmd = 'yarn ' + method + ' ' + packages.join(' ');\n    if (!cwd) {\n      cwd = process.cwd();\n    }\n    debug('%s$ %s', cwd, cmd);\n\n    if (!live) {\n      debug('[skipping - dry run]');\n      return resolve();\n    }\n\n    exec(\n      cmd,\n      {\n        cwd,\n      },\n      (error, stdout, stderr) => {\n        if (error) {\n          return reject(error);\n        }\n\n        if (stderr.indexOf('ERR!') !== -1) {\n          console.error(stderr.trim());\n          const e = new CustomError('Yarn update issues: ' + stderr.trim());\n          e.strCode = 'FAIL_UPDATE';\n          e.code = 422;\n          return reject(e);\n        }\n\n        debug('yarn %s complete', method);\n\n        resolve();\n      },\n    );\n  });\n}\n","const { v4: uuidv4 } = require('uuid');\nconst debug = require('debug')('snyk');\nconst diff = require('diff');\nconst exec = require('child_process').exec;\nconst path = require('path');\nconst fs = require('fs');\nconst semver = require('semver');\nconst { addDataAndSend } = require('../analytics');\n\nfunction applyPatch(patchFileName, vuln, live, patchUrl) {\n  let cwd = vuln.source;\n\n  return new Promise((resolve, reject) => {\n    if (!cwd) {\n      cwd = process.cwd();\n    }\n\n    const relative = path.relative(process.cwd(), cwd);\n    debug('DRY RUN: relative: %s', relative);\n\n    try {\n      let pkg = {};\n      const packageJsonPath = path.resolve(relative, 'package.json');\n      try {\n        const packageJson = fs.readFileSync(packageJsonPath);\n        pkg = JSON.parse(packageJson);\n        debug('package at patch target location: %s@%s', pkg.name, pkg.version);\n      } catch (err) {\n        debug(\n          'Failed loading package.json at %s. Skipping patch!',\n          packageJsonPath,\n          err,\n        );\n        return resolve();\n      }\n\n      const versionOfPackageToPatch = pkg.version;\n      const patchableVersionsRange = vuln.patches.version;\n\n      const isSemverMatch = semver.satisfies(\n        versionOfPackageToPatch,\n        patchableVersionsRange,\n      );\n\n      const isVersionMatch = semver.satisfies(\n        versionOfPackageToPatch,\n        semver.valid(semver.coerce(vuln.patches.version)),\n      );\n\n      if (isSemverMatch || isVersionMatch) {\n        debug(\n          'Patch version range %s matches package version %s',\n          patchableVersionsRange,\n          versionOfPackageToPatch,\n        );\n      } else {\n        debug(\n          'Patch version range %s does not match package version %s. Skipping patch!',\n          patchableVersionsRange,\n          versionOfPackageToPatch,\n        );\n        return resolve();\n      }\n\n      const patchContent = fs.readFileSync(\n        path.resolve(relative, patchFileName),\n        'utf8',\n      );\n\n      jsDiff(patchContent, relative, live).then(() => {\n        debug('patch succeed');\n        resolve();\n      });\n    } catch (error) {\n      debug('patch command failed', relative, error);\n      patchError(error, relative, vuln, patchUrl).catch(reject);\n    }\n  });\n}\n\nfunction jsDiff(patchContent, relative, live) {\n  const patchedFiles = {};\n  return new Promise((resolve, reject) => {\n    diff.applyPatches(patchContent, {\n      loadFile: function(index, callback) {\n        try {\n          const fileName = trimUpToFirstSlash(index.oldFileName);\n          if (patchedFiles[fileName]) {\n            return callback(null, patchedFiles[fileName]);\n          }\n\n          const filePath = path.resolve(relative, fileName);\n          const content = fs.readFileSync(filePath, 'utf8');\n\n          // create an `.orig` copy of the file prior to patching it\n          // used in case we need to revert a patch\n          const origFilePath = filePath + '.orig';\n          fs.writeFileSync(origFilePath, content);\n\n          callback(null, content);\n        } catch (err) {\n          // collect patch metadata for error analysis\n          err.patchIssue = JSON.stringify(index);\n          callback(err);\n        }\n      },\n      patched: function(index, content, callback) {\n        try {\n          if (content === false) {\n            // `false` means the patch does not match the original content.\n            const error = new Error('Found a mismatching patch');\n            error.patchIssue = JSON.stringify(index);\n            throw error;\n          }\n          const newFileName = trimUpToFirstSlash(index.newFileName);\n          const oldFileName = trimUpToFirstSlash(index.oldFileName);\n          if (newFileName !== oldFileName) {\n            patchedFiles[oldFileName] = null;\n          }\n          patchedFiles[newFileName] = content;\n          callback();\n        } catch (err) {\n          callback(err);\n        }\n      },\n      compareLine: function(_, line, operation, patchContent) {\n        if (operation === ' ') {\n          // Ignore when no patch operators as GNU patch does\n          return true;\n        }\n        return line === patchContent;\n      },\n      complete: function(error) {\n        if (error) {\n          return reject(error);\n        }\n        if (!live) {\n          return resolve();\n        }\n        try {\n          // write patched files back to disk, unlink files completely removed by patching\n          for (const fileName in patchedFiles) {\n            if (typeof patchedFiles[fileName] === 'string') {\n              fs.writeFileSync(\n                path.resolve(relative, fileName),\n                patchedFiles[fileName],\n              );\n            } else {\n              fs.unlinkSync(path.resolve(relative, fileName));\n            }\n          }\n          resolve();\n        } catch (err) {\n          reject(err);\n        }\n      },\n    });\n  });\n}\n\n// diff data compares the same file with a dummy path (a/path/to/real.file vs b/path/to/real.file)\n// skipping the dummy folder name by trimming up to the first slash\nfunction trimUpToFirstSlash(fileName) {\n  return fileName && fileName.replace(/^[^/]+\\//, '');\n}\n\nfunction patchError(error, dir, vuln, patchUrl) {\n  if (error && error.code === 'ENOENT') {\n    error.message =\n      'Failed to patch: the target could not be found (' + error.message + ').';\n    return Promise.reject(error);\n  }\n\n  return new Promise((resolve, reject) => {\n    const id = vuln.id;\n\n    exec(\n      'npm -v',\n      {\n        env: process.env,\n      },\n      (npmVError, versions) => {\n        // stderr is ignored\n        const npmVersion = versions && versions.split('\\n').shift();\n        const referenceId = uuidv4();\n\n        // this is a general \"patch failed\", since we already check if the\n        // patch was applied via a flag, this means something else went\n        // wrong, so we'll ask the user for help to diagnose.\n        const filename = path.relative(process.cwd(), dir);\n\n        // post metadata to help diagnose\n        addDataAndSend({\n          command: 'patch-fail',\n          metadata: {\n            from: vuln.from.slice(1),\n            vulnId: id,\n            packageName: vuln.name,\n            packageVersion: vuln.version,\n            package: vuln.name + '@' + vuln.version,\n            patchError: Object.assign(\n              {},\n              {\n                message: error.message,\n                stack: error.stack,\n                name: error.name,\n              },\n              error,\n            ),\n            'npm-version': npmVersion,\n            referenceId: referenceId,\n            patchUrl: patchUrl,\n            filename: filename,\n          },\n        });\n\n        const msg =\n          id +\n          ' on ' +\n          vuln.name +\n          '@' +\n          vuln.version +\n          ' at \"' +\n          filename +\n          '\"\\n' +\n          error +\n          ', ' +\n          'reference ID: ' +\n          referenceId +\n          '\\n';\n\n        error = new Error(msg);\n        error.code = 'FAIL_PATCH';\n\n        reject(error);\n      },\n    );\n  });\n}\n\nmodule.exports = applyPatch;\n","module.exports = dedupe;\n\nconst debug = require('debug')('snyk:patch');\nconst patchesForPackage = require('./patches-for-package');\n\nfunction dedupe(source) {\n  const removed = [];\n\n  const names = source.reduce((acc, vuln) => {\n    if (Array.isArray(vuln.patches)) {\n      // strip down to the only paches that can be applied\n      vuln.patches = patchesForPackage(vuln);\n    }\n\n    const key = vuln.name + vuln.version + vuln.from.join('>');\n\n    const other = acc[key];\n    if (other) {\n      debug('dupe found on %s & %s', vuln.id, other.id);\n      if (vuln.publicationTime > other.publicationTime) {\n        debug('stripping %s', other.id);\n        removed.push(other);\n        acc[key] = vuln;\n      } else {\n        removed.push(vuln);\n      }\n    } else {\n      acc[key] = vuln;\n    }\n\n    return acc;\n  }, {});\n\n  // turn back into an array\n  const packages = Object.keys(names).map((key) => {\n    return names[key];\n  });\n\n  return {\n    packages: packages,\n    removed: removed,\n  };\n}\n","module.exports = getVulnSource;\n\nconst debug = require('debug')('snyk');\nconst resolve = require('snyk-resolve');\nconst path = require('path');\nconst statSync = require('fs').statSync;\nconst { parsePackageString: moduleToObject } = require('snyk-module');\n\nfunction getVulnSource(vuln, live) {\n  const from = vuln.from.slice(1).map((pkg) => {\n    return moduleToObject(pkg).name;\n  });\n\n  const viaPath = path.resolve(\n    process.cwd(),\n    'node_modules',\n    from.join('/node_modules/'),\n  );\n\n  let source = vuln.__filename ? path.dirname(vuln.__filename) : viaPath;\n\n  // try to stat the directory, if it throws, it doesn't exist...\n  try {\n    statSync(source);\n  } catch (e) {\n    // ...which means the package is located in a parent path (from an\n    // npm dedupe process), so we remove the module name from the path\n    // and use the `resolve` package to navigate the node_modules up\n    // through parent directories.\n    try {\n      source = resolve.sync(from.slice(-1).pop(), viaPath);\n    } catch (e) {\n      let adaptedError = e;\n      if (e.code === 'NO_PACKAGE_FOUND') {\n        adaptedError =\n          'Error: `' +\n          e.message +\n          \"`\\nWe can't patch without \" +\n          'dependencies installed. Please run `npm ' +\n          'install` or  `yarn install` first.';\n      }\n      if (live) {\n        throw adaptedError;\n      }\n\n      // otherwise this is a dry run so we don't mind that it won't be\n      // able to patch - likely a scenario run, so it's fine that the\n      // patch target won't be found\n    }\n    debug('found better source for package: %s', source);\n  }\n\n  return source;\n}\n","module.exports = ignore;\n\nconst debug = require('debug')('snyk');\nconst stripVersions = require('./strip-versions');\nconst oneDay = 1000 * 60 * 60 * 24;\n\nfunction ignore(data) {\n  return new Promise((resolve) => {\n    const config = {};\n    config.ignore = data\n      .map((res) => {\n        const vuln = res.vuln;\n        const days = res.meta.days || 30;\n        const ignoreRule = {};\n        ignoreRule[stripVersions(vuln.from.slice(1)).join(' > ')] = {\n          reason: res.meta.reason,\n          expires: new Date(Date.now() + oneDay * days).toJSON(),\n        };\n        ignoreRule.vulnId = vuln.id;\n        return ignoreRule;\n      })\n      .reduce((acc, curr) => {\n        if (!acc[curr.vulnId]) {\n          acc[curr.vulnId] = [];\n        }\n\n        const id = curr.vulnId;\n        delete curr.vulnId;\n        acc[id].push(curr);\n\n        return acc;\n      }, {});\n\n    // final format looks like test/fixtures/protect-interactive-config.json\n    debug('ignore config', config);\n\n    resolve(config);\n  });\n}\n","const protect = (module.exports = {\n  ignore: require('./ignore'),\n  update: require('./update').update,\n  install: require('./update').install,\n  installDev: require('./update').installDev,\n  patch: require('./patch'),\n  patchesForPackage: require('./patches-for-package'),\n  generatePolicy: generatePolicy,\n});\n\nconst debug = require('debug')('snyk');\n\nconst flattenDeep = require('lodash.flattendeep');\nconst merge = require('lodash.merge');\n\nfunction generatePolicy(policy, tasks, live, packageManager) {\n  const promises = ['ignore', 'update', 'patch']\n    .filter((task) => {\n      return tasks[task].length;\n    })\n    .map((task) => {\n      return protect[task](tasks[task], live, packageManager);\n    });\n\n  return Promise.all(promises).then((res) => {\n    // we're squashing the arrays of arrays into a flat structure\n    // with only non-false values\n    const results = flattenDeep(res).filter(Boolean);\n\n    // then we merge the configs together using the original config\n    // as the baseline (this lets us retain the user's existing config)\n    results.unshift(policy);\n    const newPolicy = merge(...results);\n\n    debug(JSON.stringify(newPolicy, '', 2));\n\n    return newPolicy;\n  });\n}\n","module.exports = patch;\n\nconst now = new Date();\n\nconst debug = require('debug')('snyk');\nconst chalk = require('chalk');\nconst glob = require('glob');\nconst tempy = require('tempy');\nconst fs = require('fs');\nconst path = require('path');\nconst flatten = require('lodash.flatten');\nconst cloneDeep = require('lodash.clonedeep');\nconst { contactSupportMessage } = require('../common');\nconst applyPatch = require('./apply-patch');\nconst stripVersions = require('./strip-versions');\nconst getVulnSource = require('./get-vuln-source');\nconst dedupe = require('./dedupe-patches');\nconst writePatchFlag = require('./write-patch-flag');\nconst { spinner } = require('../spinner');\nconst errors = require('../errors/legacy-errors');\nconst analytics = require('../analytics');\nconst { default: getPatchFile } = require('./fetch-patch');\n\nfunction patch(vulns, live) {\n  const lbl = 'Applying patches...';\n  const errorList = [];\n\n  return (\n    spinner(lbl)\n      .then(() => {\n        // the target directory where our module name will live\n        vulns.forEach((vuln) => (vuln.source = getVulnSource(vuln, live)));\n\n        const deduped = dedupe(vulns);\n        debug('patching %s vulns after dedupe', deduped.packages.length);\n\n        // find the patches, pull them down off the web, save them in a temp file\n        // then apply each individual patch - but do it one at a time (via reduce)\n        const promises = deduped.packages.reduce((acc, vuln) => {\n          return acc.then((res) => {\n            const patches = vuln.patches; // this is also deduped in `dedupe`\n\n            if (patches === null) {\n              debug('no patch available for ' + vuln.id);\n              analytics.add('no-patch', vuln.from.slice(1).join(' > '));\n              return res;\n            }\n\n            analytics.add('patch', vuln.from.slice(1).join(' > '));\n            debug(`Patching vuln: ${vuln.id} ${vuln.from}`);\n\n            // the colon doesn't like Windows, ref: https://git.io/vw2iO\n            const fileSafeId = vuln.id.replace(/:/g, '-');\n            const flag = path.resolve(\n              vuln.source,\n              '.snyk-' + fileSafeId + '.flag',\n            );\n            const oldFlag = path.resolve(\n              vuln.source,\n              '.snyk-' + vuln.id + '.flag',\n            );\n\n            // get the patches on the local fs\n            const promises = patches.urls.map((url) => {\n              const filename = tempy.file({\n                extension: '.' + fileSafeId + '.snyk-patch',\n              });\n              return getPatchFile(url, filename)\n                .then((patch) => {\n                  // check whether there's a trace of us having patched before\n                  return Promise.resolve(fs.existsSync(flag))\n                    .then((exists) => {\n                      // if the file doesn't exist, look for the old style filename\n                      // in case and for backwards compatability\n                      return exists || fs.existsSync(oldFlag);\n                    })\n                    .then((exists) => {\n                      if (!exists) {\n                        return patch;\n                      }\n                      debug(\n                        'Previous flag found = ' +\n                          exists +\n                          ' | Restoring file back to original to apply the patch again',\n                      );\n                      // else revert the patch\n                      return new Promise((resolve, reject) => {\n                        // find all backup files that do not belong to transitive deps\n                        glob(\n                          '**/*.orig',\n                          { cwd: vuln.source, ignore: '**/node_modules/**' },\n                          (error, files) => {\n                            if (error) {\n                              return reject(error);\n                            }\n\n                            // copy '.orig' backups over the patched files\n                            for (const file of files) {\n                              const backupFile = path.resolve(\n                                vuln.source,\n                                file,\n                              );\n                              const sourceFile = backupFile.slice(\n                                0,\n                                -'.orig'.length,\n                              );\n                              debug('restoring', backupFile, sourceFile);\n                              fs.renameSync(backupFile, sourceFile);\n                            }\n\n                            resolve(patch);\n                          },\n                        );\n                      });\n                    });\n                })\n                .then((patch) => {\n                  if (patch === false) {\n                    debug('already patched %s', vuln.id);\n                    return vuln;\n                  }\n\n                  debug(\n                    'applying patch file for %s: \\n%s\\n%s',\n                    vuln.id,\n                    url,\n                    patch,\n                  );\n\n                  return applyPatch(patch, vuln, live, url)\n                    .then(\n                      () => {\n                        return true;\n                      },\n                      (e) => {\n                        errorList.push(e);\n                        return false;\n                      },\n                    )\n                    .then(writePatchFlag(now, vuln))\n                    .then((ok) => {\n                      return ok ? vuln : false;\n                    });\n                });\n            });\n\n            return Promise.all(promises).then((result) => {\n              res.push(result);\n              return res; // this is what makes the waterfall reduce chain work\n            });\n          });\n        }, Promise.resolve(deduped.removed));\n\n        const promise = promises\n          .then((res) => {\n            const patched = flatten(res).filter(Boolean);\n\n            if (!live) {\n              debug('[skipping - dry run]');\n              return patched;\n            }\n            return Promise.all(patched);\n          })\n          .then((patched) => {\n            const config = {};\n\n            // this reduce function will look to see if the patch actually resolves\n            // more than one vulnerability, and if it does, it'll replicate the\n            // patch rule against the *other* vuln.ids. This will happen when the user\n            // runs the wizard and selects to apply a patch that fixes more than one\n            // vuln.\n            const mapped = patched.map(patchRule).reduce((acc, curr, i) => {\n              const vuln = patched[i];\n              if (vuln.grouped && vuln.grouped.includes) {\n                vuln.grouped.includes.forEach((id) => {\n                  const rule = cloneDeep(curr);\n                  rule.vulnId = id;\n                  acc.push(rule);\n                });\n              }\n\n              acc.push(curr);\n\n              return acc;\n            }, []);\n\n            config.patch = mapped.reduce((acc, curr) => {\n              if (!acc[curr.vulnId]) {\n                acc[curr.vulnId] = [];\n              }\n\n              const id = curr.vulnId;\n              delete curr.vulnId;\n              acc[id].push(curr);\n\n              return acc;\n            }, {});\n\n            debug('patched', config);\n\n            return config;\n          });\n\n        return promise;\n      })\n      // clear spinner in case of success or failure\n      .then(spinner.clear(lbl))\n      .catch((error) => {\n        spinner.clear(lbl)();\n        throw error;\n      })\n      .then((res) => {\n        if (errorList.length) {\n          errorList.forEach((error) => {\n            console.log(chalk.red(errors.message(error)));\n            debug(error.stack);\n          });\n          throw new Error(contactSupportMessage);\n        }\n\n        return res;\n      })\n  );\n}\n\nfunction patchRule(vuln) {\n  const rule = {\n    vulnId: vuln.id,\n  };\n  rule[stripVersions(vuln.from.slice(1)).join(' > ')] = {\n    patched: now.toJSON(),\n  };\n  return rule;\n}\n","module.exports = patchesForPackage;\n\nconst semver = require('semver');\n\nfunction patchesForPackage(vuln) {\n  return (\n    vuln.patches.filter((patch) => {\n      if (semver.satisfies(vuln.version, patch.version)) {\n        return (patch.urls || []).length ? patch : false;\n      }\n      return false;\n    })[0] || null\n  );\n}\n","module.exports = stripVersions;\n\nconst { parsePackageString: moduleToObject } = require('snyk-module');\n\nfunction stripVersions(packages) {\n  return packages.map((pkg) => {\n    return moduleToObject(pkg).name;\n  });\n}\n","module.exports.update = update;\nmodule.exports.install = install;\nmodule.exports.installDev = installDev;\n\nconst debug = require('debug')('snyk');\nconst chalk = require('chalk');\nconst uniq = require('lodash.uniq');\nconst isEmpty = require('lodash.isempty');\nconst { parsePackageString: moduleToObject } = require('snyk-module');\nconst semver = require('semver');\nconst errors = require('../errors/legacy-errors');\nconst { default: npm } = require('../npm');\nconst { yarn } = require('../yarn');\nconst { spinner } = require('../spinner');\nconst analytics = require('../analytics');\n\nfunction update(packages, live, pkgManager) {\n  pkgManager = pkgManager || 'npm';\n  const lbl = 'Applying updates using ' + pkgManager + '...';\n  let error = false;\n\n  return (\n    spinner(lbl)\n      .then(() => {\n        const upgrade = packages\n          .map((vuln) => {\n            const remediation = vuln.upgradePath && vuln.upgradePath[1];\n            if (!remediation) {\n              // this vuln holds an unreachable upgrade path - send this to analytics\n              // and return an empty object to be filtered\n              analytics.add('bad-upgrade-path', vuln);\n              return null;\n            }\n\n            return {\n              remediation: remediation,\n              type: vuln.parentDepType || 'prod',\n            };\n          })\n          .filter(Boolean)\n          .reduce((ups, vuln) => {\n            if (!ups[vuln.type]) {\n              ups[vuln.type] = [];\n            }\n            ups[vuln.type].push(vuln.remediation);\n            return ups;\n          }, {});\n\n        debug('to upgrade', upgrade);\n\n        if (upgrade.length === 0) {\n          return;\n        }\n\n        // warn if extraneous packages were selected for update\n        if (upgrade.extraneous) {\n          console.error(\n            chalk.yellow(\n              'Extraneous packages were selected for ' +\n                'update, but will be skipped. These dependencies introduce ' +\n                'vulnerabilities. Please remove the dependencies with `npm prune`, ' +\n                'or install properly as prod or dev dependencies:',\n              upgrade.extraneous.join(', '),\n            ),\n          );\n        }\n\n        const promise = Promise.resolve()\n          .then(() => {\n            // create list of unique package names _without versions_ for uninstall\n            // skip extraneous packages, if any\n            const prodToUninstall =\n              (upgrade.prod && upgrade.prod.map(stripVersion)) || [];\n            const devToUninstall =\n              (upgrade.dev && upgrade.dev.map(stripVersion)) || [];\n            const toUninstall = uniq(prodToUninstall.concat(devToUninstall));\n            debug('to uninstall', toUninstall);\n\n            if (!isEmpty(toUninstall)) {\n              return uninstall(pkgManager, toUninstall, live);\n            }\n          })\n          .then(() => {\n            const prodUpdate = (upgrade.prod\n              ? install(pkgManager, findUpgrades(upgrade.prod), live)\n              : Promise.resolve(true)\n            ).catch((e) => {\n              error = e;\n              return false;\n            });\n            const devUpdate = (upgrade.dev\n              ? installDev(pkgManager, findUpgrades(upgrade.dev), live)\n              : Promise.resolve(true)\n            ).catch((e) => {\n              error = e;\n              return false;\n            });\n            return Promise.all([prodUpdate, devUpdate]).then((results) => {\n              return results[0] && results[1];\n            });\n          });\n        return promise;\n      })\n      // clear spinner in case of success or failure\n      .then(spinner.clear(lbl))\n      .catch((error) => {\n        spinner.clear(lbl)();\n        throw error;\n      })\n      .then((res) => {\n        if (error) {\n          console.error(chalk.red(errors.message(error)));\n          debug(error.stack);\n        }\n        return res;\n      })\n  );\n}\n\nfunction install(pkgManager, upgrades, live) {\n  return pkgManager === 'yarn'\n    ? yarn('add', upgrades, live)\n    : npm('install', upgrades, live);\n}\n\nfunction installDev(pkgManager, upgrades, live) {\n  return pkgManager === 'yarn'\n    ? yarn('add', upgrades, live, null, ['--dev'])\n    : npm('install', upgrades, live, null, ['--save-dev']);\n}\n\nfunction uninstall(pkgManager, toUninstall, live) {\n  return pkgManager === 'yarn'\n    ? yarn('remove', toUninstall, live)\n    : npm('uninstall', toUninstall, live);\n}\n\nfunction findUpgrades(packages) {\n  return packages\n    .map(moduleToObject)\n    .reduce((acc, curr) => {\n      const have = acc\n        .filter((pkg) => {\n          return pkg.name === curr.name;\n        })\n        .pop();\n\n      if (have) {\n        if (semver.gt(curr.version, have.version)) {\n          have.version = curr.version;\n        }\n      } else {\n        acc.push(curr);\n      }\n\n      return acc;\n    }, [])\n    .map((pkg) => {\n      return pkg.name + '@' + pkg.version;\n    });\n}\n\nfunction stripVersion(pkg) {\n  if (!pkg) {\n    return;\n  }\n\n  // scoped packages like @snyk/module@1.0.0\n  if (pkg.startsWith('@')) {\n    return '@' + pkg.split('@')[1];\n  }\n\n  // non-scoped packages like snyk@1.2.3\n  if (pkg.indexOf('@') > 0) {\n    return pkg.split('@').shift();\n  }\n\n  // versionless packages like tap\n  return pkg;\n}\n","module.exports = writePatchFlag;\n\nconst debug = require('debug')('snyk');\nconst fs = require('fs');\nconst path = require('path');\n\nfunction writePatchFlag(now, vuln) {\n  if (!vuln) {\n    vuln = now;\n    now = new Date();\n  }\n\n  debug('writing flag for %s', vuln.id);\n  let promise;\n  // the colon doesn't like Windows, ref: https://git.io/vw2iO\n  const fileSafeId = vuln.id.replace(/:/g, '-');\n  const flag = path.resolve(vuln.source, '.snyk-' + fileSafeId + '.flag');\n  if (vuln.grouped && vuln.grouped.includes) {\n    debug('found addition vulns to write flag files for');\n    const writePromises = [];\n    fs.writeFileSync(flag, now.toJSON(), 'utf8');\n    vuln.grouped.includes.forEach(() => {\n      const fileSafeId = vuln.id.replace(/:/g, '-');\n      const flag = path.resolve(vuln.source, '.snyk-' + fileSafeId + '.flag');\n      debug('Writing flag for grouped vulns', flag);\n      writePromises.push();\n      fs.writeFileSync(flag, now.toJSON(), 'utf8');\n    });\n    promise = Promise.all(writePromises);\n  } else {\n    debug('Writing flag for single vuln', flag);\n    /* TODO:\n      This piece is actually swallowing fs.writeFile errors!\n      See the `promise.then` construct below.\n      This should be refactored and tests should be updated.\n    */\n    promise = new Promise((r) => fs.writeFile(flag, now.toJSON(), 'utf8', r));\n  }\n  return promise.then(() => {\n    return vuln;\n  });\n}\n"],"names":[],"sourceRoot":""}