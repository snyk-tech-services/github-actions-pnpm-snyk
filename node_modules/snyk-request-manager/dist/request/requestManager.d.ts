import { LeakyBucketQueue } from 'leaky-bucket-queue';
import { snykRequest } from './request';
interface queuedRequest {
    id: string;
    channel: string;
    snykRequest: snykRequest;
}
interface queueCallbackListenerBundle {
    callback(requestId: string, data: any): void;
    channel?: string;
}
declare enum eventType {
    data = "data",
    error = "error"
}
interface responseEvent {
    eventType: eventType;
    channel: string;
    requestId: string;
    data: any;
}
interface requestsManagerParams {
    snykToken?: string;
    burstSize?: number;
    period?: number;
    maxRetryCount?: number;
    userAgentPrefix?: string;
}
declare class requestsManager {
    _requestsQueue: LeakyBucketQueue<queuedRequest>;
    _events: any;
    _retryCounter: Map<string, number>;
    _MAX_RETRY_COUNT: number;
    _snykToken: string;
    _userAgentPrefix: string;
    constructor(params?: requestsManagerParams);
    _setupQueueExecutors: (queue: LeakyBucketQueue<queuedRequest>) => void;
    _makeRequest: (request: queuedRequest) => Promise<void>;
    _queueErrorHandler: (err: Error) => never;
    _emit: (response: responseEvent) => void;
    _removeAllListenersForChannel: (channel: string) => void;
    _doesChannelHaveListeners: (channel: string) => boolean;
    request: (request: snykRequest) => Promise<any>;
    requestBulk: (snykRequestsArray: Array<snykRequest>) => Promise<Array<Object>>;
    requestStream: (request: snykRequest, channel?: string, id?: string) => string;
    on: (eventType: string, listenerBundle: queueCallbackListenerBundle) => void;
}
export { requestsManager };
