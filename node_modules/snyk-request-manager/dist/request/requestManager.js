"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.requestsManager = void 0;
const leaky_bucket_queue_1 = require("leaky-bucket-queue");
const request_1 = require("./request");
const uuid_1 = require("uuid");
const requestsManagerError = require("../customErrors/requestManagerErrors");
var eventType;
(function (eventType) {
    eventType["data"] = "data";
    eventType["error"] = "error";
})(eventType || (eventType = {}));
class requestsManager {
    //snykToken = '', burstSize = 10, period = 500, maxRetryCount = 5
    constructor(params = {}) {
        this._setupQueueExecutors = (queue) => {
            queue.consume().subscribe({
                next: this._makeRequest,
                error: this._queueErrorHandler,
                complete: () => {
                    console.log("Stopped queue");
                }
            });
        };
        this._makeRequest = async (request) => {
            let requestId = request.id;
            try {
                let response = await request_1.makeSnykRequest(request.snykRequest, this._snykToken, this._userAgentPrefix);
                this._emit({ eventType: eventType.data, channel: request.channel, requestId: requestId, data: response });
            }
            catch (err) {
                let overloadedError = requestsManagerError.requestsManagerErrorOverload(err, request.channel, requestId);
                let alreadyRetriedCount = this._retryCounter.get(requestId) || 0;
                if (alreadyRetriedCount >= this._MAX_RETRY_COUNT) {
                    this._emit({ eventType: eventType.error, channel: request.channel, requestId: requestId, data: overloadedError });
                }
                else {
                    this._retryCounter.set(requestId, alreadyRetriedCount + 1);
                    // Throw it back into the queue
                    this.requestStream(request.snykRequest, request.channel, request.id);
                }
            }
        };
        this._queueErrorHandler = (err) => {
            //debug(err)
            // TODO: Add retry logic
            // Track request ID count and throw it back into the queue
            // Throw error when count > MAX_RETRIES_LIMIT
            throw new Error(err.stack);
        };
        this._emit = (response) => {
            if (!this._events[response.eventType]) {
                throw new Error(`Can't emit an event. Event "${eventType}" doesn't exits.`);
            }
            const fireCallbacks = (listenerBundle) => {
                if (response.channel == listenerBundle.channel) {
                    listenerBundle.callback(response.requestId, response.data);
                }
            };
            this._events[response.eventType].forEach(fireCallbacks);
        };
        this._removeAllListenersForChannel = (channel) => {
            Object.keys(eventType).forEach(typeOfEvent => {
                if (!this._events[typeOfEvent]) {
                    throw new Error(`Can't remove a listener. Event "${typeOfEvent}" doesn't exits.`);
                }
                const filterListeners = (callbackListener) => callbackListener.channel !== channel;
                this._events[typeOfEvent] = this._events[typeOfEvent].filter(filterListeners);
            });
        };
        this._doesChannelHaveListeners = (channel) => {
            let dataEventListeners = this._events['data'];
            return dataEventListeners.some(listener => listener.channel == channel);
        };
        this.request = (request) => {
            return new Promise((resolve, reject) => {
                let syncRequestChannel = uuid_1.v4();
                const callbackBundle = {
                    callback: (originalRequestId, data) => {
                        if (requestId == originalRequestId) {
                            this._removeAllListenersForChannel(syncRequestChannel);
                            resolve(data);
                        }
                    },
                    channel: syncRequestChannel
                };
                const errorCallbackBundle = {
                    callback: (originalRequestId, data) => {
                        if (requestId == originalRequestId) {
                            this._removeAllListenersForChannel(syncRequestChannel);
                            reject(data);
                        }
                    },
                    channel: syncRequestChannel
                };
                this.on('data', callbackBundle);
                this.on('error', errorCallbackBundle);
                let requestId = this.requestStream(request, syncRequestChannel);
            });
        };
        this.requestBulk = (snykRequestsArray) => {
            return new Promise((resolve, reject) => {
                // Fire off all requests in Array and return only when responses are all returned
                // Must return array of responses in the same order.
                let requestsMap = new Map();
                let bulkRequestChannel = uuid_1.v4();
                let isErrorInAtLeastOneRequest = false;
                let requestRemainingCount = snykRequestsArray.length;
                const callbackBundle = {
                    callback: (originalRequestId, data) => {
                        requestsMap.set(originalRequestId, data);
                        requestRemainingCount--;
                        if (requestRemainingCount <= 0) {
                            let responsesArray = [];
                            requestsMap.forEach((value) => {
                                responsesArray.push(value);
                            });
                            isErrorInAtLeastOneRequest ? reject(responsesArray) : resolve(responsesArray);
                        }
                    },
                    channel: bulkRequestChannel
                };
                const errorCallbackBundle = {
                    callback: (originalRequestId, data) => {
                        isErrorInAtLeastOneRequest = true;
                        callbackBundle.callback(originalRequestId, data);
                    },
                    channel: bulkRequestChannel
                };
                this.on('data', callbackBundle);
                this.on('error', errorCallbackBundle);
                snykRequestsArray.forEach(snykRequest => {
                    requestsMap.set(this.requestStream(snykRequest, bulkRequestChannel), {});
                });
            });
        };
        this.requestStream = (request, channel = 'stream', id = '') => {
            let requestId = id ? id : uuid_1.v4();
            let requestForQueue = { id: requestId, channel: channel, snykRequest: request };
            this._requestsQueue.enqueue(requestForQueue);
            if (!this._doesChannelHaveListeners(channel)) {
                throw new Error(`Not listener(s) setup for channel ${channel}`);
            }
            return requestId;
        };
        this.on = (eventType, listenerBundle) => {
            if (!this._events[eventType]) {
                this._events[eventType] = [];
            }
            if (!listenerBundle.channel) {
                listenerBundle.channel = 'stream';
            }
            this._events[eventType].push(listenerBundle);
        };
        this._requestsQueue = new leaky_bucket_queue_1.LeakyBucketQueue({ burstSize: (params === null || params === void 0 ? void 0 : params.burstSize) || 10, period: (params === null || params === void 0 ? void 0 : params.period) || 500 });
        this._setupQueueExecutors(this._requestsQueue);
        this._events = {};
        this._retryCounter = new Map();
        this._MAX_RETRY_COUNT = (params === null || params === void 0 ? void 0 : params.maxRetryCount) || 5;
        this._snykToken = (params === null || params === void 0 ? void 0 : params.snykToken) || '';
        this._userAgentPrefix = (params === null || params === void 0 ? void 0 : params.userAgentPrefix) || '';
    }
}
exports.requestsManager = requestsManager;
//# sourceMappingURL=requestManager.js.map