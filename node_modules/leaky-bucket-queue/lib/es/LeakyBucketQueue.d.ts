import { Observable, SchedulerLike } from 'rxjs';
/** @public */
export interface QueueOption {
    /**
     * Amount of object that can be bursted in initial phase, aka bucket size.
     */
    burstSize: number;
    /**
     * Amount of time before another token is generated. Frequency could be converted to period with
     * formula T = 1/f.
     */
    period: number;
    /**
     * An scheduler for scheduling emission.
     */
    scheduler?: SchedulerLike;
}
/**
 * This queue is a simple implementation of leaky bucket algorithm, in terms of number of emitted
 * object. The burst object will by default emitted synchronously.
 * @public
 */
export declare class LeakyBucketQueue<T> {
    private option;
    private bucket;
    private subject;
    private queue;
    private timer?;
    private timerStarted;
    constructor(option: QueueOption);
    private assertOption;
    private assertValue;
    consume(): Observable<T>;
    /**
     * Queues data for emit at scheduled time. By default burst will be emitted synchronously. If
     * consistency is desired (emit item like the delayed item, asynchronously), then a scheduler
     * could be used to override this behaviour.
     * @param data - data to be queued
     */
    enqueue(data: T): void;
    /** @internal */
    private startTimer;
    /**
     * Stops the leaky bucket timer and return remaining item on queue for persistence or clean up.
     */
    stop(): T[];
}
